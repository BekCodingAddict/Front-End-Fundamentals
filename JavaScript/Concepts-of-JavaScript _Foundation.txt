-------------------------------JAVASCRIPT--------------------------------------------                       
JS Data Types:
   JavaScript Types are Dynamic. This means the same variable can used to hold diffrent data types:
   let x; //Undefined
   x=5; // Number 
   x="John"; // String

JS Numbers:
  All JavaScript numbers are stored as decimal numbers(floating point);
  All JavaScript numbers are stored in a a 64-bit floating-point format.
  JavaScript BigInt is a new datatype (ES2020) that can be used to store integer values that are too big to be represented by a normal JavaScript Number.


JS Exponential Notation:
  Extra large or extra small numbers can be written with scientific (exponential) notation:
  let y = 123e5;    // 12300000
  let z = 123e-5;   // 0.00123

JS Arrays:
  JavaScript arrays are written with square brackets.
  Array items are separated by commas.
  Array indexes are zero-based, which means the first item is [0], second is [1], and so on.

JS Object:
  JavaScript objects are written with curly braces {}.

JS The typeof Operator:
  You can use the JavaScript typeof operator to find the type of a JavaScript variable.
  The typeof operator returns the type of a variable or an expression.

JS Undefined:
  In JavaScript, a variable without a value, has the value undefined. The type is also undefined.

JS Empty Values:
  An empty value has nothing to do with undefined.
  An empty string has both a legal value and a type.

JS Functions:
  A JavaScript function is a block of code designed to perform a particular task.
  A JavaScript function is defined with the function keyword, followed by a name, followed by parentheses ().
  Function names can contain letters, digits, underscores, and dollar signs (same rules as variables).
  Functions can be used the same way as you use variables, in all types of formulas, assignments, and calculations.

JS Objects:
  Real Life Objects, Properties, and Methods.
  In real life, a car is an object.
  A car has properties like weight and color, and methods like start and stop.
  All cars have the same properties, but the property values differ from car to car.
  All cars have the same methods, but the methods are performed at different times.
  - Comparing two JavaScript objects always returns false.
  
  Objects are variables too. But objects can contain many values.
  It is a common practice to declare objects with the const keyword.
  JavaScript objects are containers for named values called properties.
  Objects can also have methods.
  Methods are actions that can be performed on objects.
  Methods are stored in properties as function definitions.
  Methods:
    A method is a function stored as a property.
  
  WHat is this?:
    In JavaScript, the this keyword refers to an object.
    Which object depends on how this is being invoked (used or called).
    The this keyword refers to different objects depending on how it is used:
      In an object method, this refers to the object.
      Alone, this refers to the global object.
      In a function, this refers to the global object.
      In a function, in strict mode, this is undefined.
      In an event, this refers to the element that received the event.
      Methods like call(), apply(), and bind() can refer this to any object.
  
    this is not a variable. It is a keyword. You cannot change the value of this.
  
  NOTE:
    When a JavaScript variable is declared with the keyword "new", the variable is created as an object.
    Do Not Declare Strings, Numbers, and Booleans as Objects!
    Avoid String, Number, and Boolean objects. They complicate your code and slow down execution speed.
JavaScript Events:
  - HTML Events:
    - An HTML event can be something the browser does, or something a user does.
      Here are some examples of HTML events:
      An HTML web page has finished loading
      An HTML input field was changed
      An HTML button was clicked
      Often, when events happen, you may want to do something.
      JavaScript lets you execute code when events are detected.
      HTML allows event handler attributes, with JavaScript code, to be added to HTML elements.

JavaScript String:
  - JavaScript strings are for storing and manipulating text.
  - A JavaScript string is zero or more characters written inside quotes.
  - You can use quotes inside a string, as long as they don't match the quotes surrounding the string.

JavaScript Breaking Long Code Lines:
  - For best readability, programmers often like to avoid code lines longer than 80 characters.
  - If a JavaScript statement does not fit on one line, 
    the best place to break it is after an operator:
  - You can also break up a code line within a text string with a single backslash:
  - The \ method is not the preferred method. It might not have universal support.
    Some browsers do not allow spaces behind the \ character.
  - A safer way to break up a string, is to use string addition.
  - You cannot break up a code line with a backslash:

JS String Methods:
  - All string methods return a new string.
    They don't modify the original string.
    Formally said:
      Strings are immutable: Strings cannot be changed, only replaced.

  - There are 3 methods for extracting a part of a string:
    - slice(start, end)
      substring(start, end)
      substr(start, length)
      substring() is similar to slice().
      - replace() 
        The replace() method does not change the string it is called on.
        The replace() method returns a new string.
        The replace() method replaces only the first match
        By default, the replace() method is case sensitive.
         Writing Upper-case string will not work:

      replaceAll()- method allows you to specify a regular expression instead of a string to be replaced.
        - Note
          replaceAll() is an ES2021 feature.
          replaceAll() does not work in Internet Explorer.
      toUpperCase()
      toUpperCase()
      concat() joins two or more strings:
        - let text1 = "Hello";
          let text2 = "World";
          let text3 = text1.concat(" ", text2);
      trim()- method removes whitespace from both sides of a string:
      trimStart()- method works like trim(),but removes whitespace only from the start of a string.
      trimEnd()- method works like trim(), but removes whitespace only from the end of a string.
      padStart()- method pads a string from the start.
      split() method:A string can be converted to an array .

  - Extracting String Characters:
    There are 3 methods for extracting string characters:
    charAt(position)
    charCodeAt(position)
    Property access [ ]


The difference is that the second parameter specifies the length of the extracted part.

  - Note
    JavaScript counts positions from zero.
    First position is 0.
    Second position is 1.

  indexOf() method returns the index (position) the first occurrence of a string in a string.
  lastIndexOf() method returns the index of the last occurrence of a specified text in a string.
    - Both indexOf(), and lastIndexOf() return -1 if the text is not found:
      Both methods accept a second parameter as the starting position for the search.
      The lastIndexOf() methods searches backwards (from the end to the beginning), meaning: if the second parameter is 15, the search starts at position 15, 
      and searches to the beginning of the string.
  search() method searches a string for a string (or a regular expression) and returns the position of the match:
    - The two methods, indexOf() and search(), are equal?
      They accept the same arguments (parameters), and return the same value?
      The two methods are NOT equal. These are the differences:
      The search() method cannot take a second start position argument.
      The indexOf() method cannot take powerful search values (regular expressions).
  match() method returns an array containing the results of matching a string against a string (or a regular expression).
  If a regular expression does not include the g modifier (global search), match() will return only the first match in the string.
 
  includes() method returns true if a string contains a specified value.
  startsWith() method returns true if a string begins with a specified value.
  endsWith() method returns true if a string ends with a specified value.

JavaScript Template Literals:
  - Interpolation:
    - Template literals provide an easy way to interpolate variables and expressions into strings.
      The method is called string interpolation.The syntax is:
      ${...}
    - Automatic replacing of expressions with real values is called string interpolation.
    
JavaScript Numbers:
  - JavaScript has only one type of number. Numbers can be written with or without decimals.
  - Extra large or extra small numbers can be written with scientific (exponent) notation:
    - let x = 123e5;    // 12300000
      let y = 123e-5;   // 0.00123
  - JavaScript Numbers are Always 64-bit Floating Point.
  - Integer Precision:
    - Integers (numbers without a period or exponent notation) are accurate up to 15 digits.
    - The maximum number of decimals is 17.
  - Floating Precision:
    - Floating point arithmetic is not always 100% accurate.
  - NaN - Not a Number:
    - NaN is a JavaScript reserved word indicating that a number is not a legal number.
      Trying to do arithmetic with a non-numeric string will result in NaN (Not a Number):
    - NaN is a number: typeof NaN returns number.
  - Infinity (or -Infinity) is the value JavaScript will return if you calculate a number outside the largest possible number.
    - Division by 0 (zero) also generates Infinity.
      - let x =  2 / 0;
        let y = -2 / 0;
    - Infinity is a number: typeof Infinity returns number.
  - Hexadecimal:
    - JavaScript interprets numeric constants as hexadecimal if they are preceded by 0x.
      - let x = 0xFF;
  
  - NOTE:
    - Never write a number with a leading zero (like 07).
      Some JavaScript versions interpret numbers as octal if they are written with a leading zero.
    - By default, JavaScript displays numbers as base 10 decimals.
      But you can use the toString() method to output numbers from base 2 to base 36.
      Hexadecimal is base 16. Decimal is base 10. Octal is base 8. Binary is base 2.
        - let myNumber = 32;
          myNumber.toString(32);
          myNumber.toString(16);
          myNumber.toString(12);
          myNumber.toString(10);
          myNumber.toString(8);
          myNumber.toString(2);
    - Comparing two JavaScript objects always returns false.!

JavaScript BigInt:
  - JavaScript BigInt variables are used to store big integer values that are too big to be represented by a normal JavaScript Number.
  - JavaScript Integer Accuracy:
    - JavaScript integers are only accurate up to 15 digits:
      - Integer Precision
        let x = 999999999999999;
        let y = 9999999999999999;
  - How to Create a BigInt:
    - To create a BigInt, append n to the end of an integer or call BigInt():
      - let y = 9999999999999999n;
      - let y = BigInt(1234567890123456789012345)
    - BigInt is the second numeric data type in JavaScript (after Number).
    - With BigInt the total number of supported data types in JavaScript is 8:
      - 1. String
        2. Number
        3. Bigint
        4. Boolean
        5. Undefined
        6. Null
        7. Symbol
        8. Object

    - Operators that can be used on a JavaScript Number can also be used on a BigInt.
    - NOTE:
      - Arithmetic between a BigInt and a Number is not allowed (type conversion lose information).
      - Unsigned right shift (>>>) can not be done on a BigInt (it does not have a fixed width).
      - A BigInt can not have decimals.
    
    - BigInt can also be written in hexadecimal, octal, or binary notation:
      - let hex = 0x20000000000003n;
        let oct = 0o400000000000000003n
        let bin = 0b100000000000000000000000000000000000000000000000000011n;

    - Precision Curiosity
        - Rounding can compromise program security:
          - MAX_SAFE_INTEGER Example:
            - 9007199254740992 === 9007199254740993; // is true !!!

JavaScript Number Methods:
  - These number methods can be used on all JavaScript numbers:
    - toString()	Returns a number as a string
      toExponential()	Returns a number written in exponential notation
      toFixed()	Returns a number written with a number of decimals:
        - toFixed(2) is perfect for working with money.
      toPrecision()	Returns a number written with a specified length
      ValueOf()	Returns a number as a number

  - Converting Variables to Numbers:
    - There are 3 JavaScript methods that can be used to convert a variable to a number:
      - Number()	Returns a number converted from its argument.
        parseFloat()	Parses its argument and returns a floating point number
        parseInt()	Parses its argument and returns a whole number:
          - Stringdagi 1 numberni aniqlaydi
  
  - Number Object Methods:
    - These object methods belong to the Number object:
      - Number.isInteger()	Returns true if the argument is an integer
        Number.isSafeInteger()	Returns true if the argument is a safe integer
        Number.parseFloat()	Converts a string to a number
        Number.parseInt()	Converts a string to a whole numbe


JavaScript Number Properties:
  - EPSILON	The difference between 1 and the smallest number > 1.
    MAX_VALUE	The largest number possible in JavaScript
    MIN_VALUE	The smallest number possible in JavaScript
    MAX_SAFE_INTEGER	The maximum safe integer (253 - 1)
    MIN_SAFE_INTEGER	The minimum safe integer -(253 - 1)
    POSITIVE_INFINITY	Infinity (returned on overflow):
      - POSITIVE_INFINITY is returned on overflow.
    NEGATIVE_INFINITY	Negative infinity (returned on overflow)
    NaN	A "Not-a-Number" value:
      - NaN is a JavaScript reserved word for a number that is not a legal number.

  - Number Properties Cannot be Used on Variables:
    - Number properties belong to the JavaScript Number Object.
      These properties can only be accessed as Number.MAX_VALUE.
      Using x.MAX_VALUE, where x is a variable or a value, will return undefined:

JavaScript Arrays:
  - It is a common practice to declare arrays with the const keyword.
  - Using the JavaScript Keyword new also create array.
    - There is no need to use new Array().For simplicity,
     readability and execution speed, use the array literal method.
  - Arrays are a special type of objects. The typeof operator in JavaScript returns "object" for arrays.
    - JavaScript variables can be objects. Arrays are special kinds of objects.
      Because of this, you can have variables of different types in the same Array.
      You can have objects in an Array. You can have functions in an Array. You can have arrays in an Array.
  - The easiest way to add a new element to an array is using the push() method:
  - New element can also be added to an array using the length property.
  - NOTE: 
    - Adding elements with high indexes can create undefined "holes" in an array.
  - Associative Arrays:
    - Many programming languages support arrays with named indexes.
      Arrays with named indexes are called associative arrays (or hashes).
      JavaScript does not support arrays with named indexes.
      In JavaScript, arrays always use numbered indexes.
    - NOTE:
      - If you use named indexes, JavaScript will redefine the array to an object.
        After that, some array methods and properties will produce incorrect results.
      - JavaScript new Array():
        - JavaScript has a built-in array constructor new Array().
          But you can safely use [] instead.
            const points = new Array();
            const points = [];
          The new keyword can produce some unexpected results.
      - A Common Error:
        - const points = [40];
          is not the same as:
          const points = new Array(40);
  - The Difference Between Arrays and Objects:
    - In JavaScript, arrays use numbered indexes.
    - In JavaScript, objects use named indexes.
    - Arrays are a special kind of objects, with numbered indexes.
    - JavaScript does not support associative arrays.
      - You should use objects when you want the element names to be strings (text).
      - You should use arrays when you want the element names to be numbers.
  - How to Recognize an Array:
    - A common question is: How do I know if a variable is an array?
      The problem is that the JavaScript operator typeof returns "object":
    - Array.isArray():
      To solve this problem ECMAScript 5 (JavaScript 2009) defined a new method Array.isArray()
    - To solve this problem ECMAScript 5 (JavaScript 2009) defined a new method Array.isArray():
      const fruits = ["Banana", "Orange", "Apple"];
      fruits instanceof Array;

--------------------JAVASCRIPT Array MEthods-----------------------------
Array Methods:
  - length property returns the length (size) of an array.
  - toString() converts an array to a string of (comma separated) array values.
  - join() method also joins all array elements into a string.
  - Popping and Pushing:
    - Popping items out of an array, or pushing items into an array.
    - pop() method removes the last element from an array.
    - push() method adds a new element to an array (at the end).
  - shift() method removes the first array element and "shifts" all other elements to a lower index.
    shift() method returns the value that was "shifted out".
  - unshift() method adds a new element to an array (at the beginning), and "unshifts" older elements.
    unshift() method returns the new array length.
  - NOTE:
    - Array elements can be deleted using the JavaScript operator delete.
      delete leaves undefined holes in the array.
      Use pop() or shift() instead.
    - JavaScript automatically converts an array to a comma separated string when a primitive value is expected.
    - Finding Max and Min Values in an Array:
      - There are no built-in functions for finding the highest or lowest value in a JavaScript array.
      
  - concat() method creates a new array by merging (concatenating) existing arrays
    concat() method does not change the existing arrays. It always returns a new array.
    concat() method can take any number of array arguments.
    concat() method can also take strings as arguments.
  - Flattening an Array:
    - Flattening an array is the process of reducing the dimensionality of an array.
      The flat() method creates a new array with sub-array elements concatenated to a specified depth.
  - splice() method adds new items to an array:
    - The first parameter (2) defines the position where new elements should be added (spliced in).
      The second parameter (0) defines how many elements should be removed.
      splice() method returns an array with the deleted items.
      With clever parameter setting, you can use splice() to remove elements without leaving "holes" in the array.

  - slice() method slices out a piece of an array.
    slice() method creates a new array.
    slice() method does not remove any elements from the source array.
  
--------------------------------JavaScript Sorting Arrays----------------------------------
- Sorting an Array:
  - sort() method sorts an array alphabetically:
    - sort() function sorts values as strings.
      However, if numbers are sorted as strings, "25" is bigger than "100", because "2" is bigger than "1".
      Because of this, the sort() method will produce incorrect result when sorting numbers.
      You can fix this by providing a compare function:
        - const points = [40, 100, 1, 5, 25, 10];
          points.sort(function(a, b){return a - b});
  - reverse() method reverses the elements in an array.
  - Sorting a whole array is a very inefficient method if you only want to find the highest (or lowest) value.
  - Math.max.apply to find the highest number in an array:
    - code:
      function myArrayMax(arr) {
        return Math.max.apply(null, arr);
      }
    
----------------------JavaScript Array Const------------------------
Arrays are Not Constants:
  - The keyword const is a little misleading.
    It does NOT define a constant array. It defines a constant reference to an array.
    Because of this, we can still change the elements of a constant array.
  - Elements Can be Reassigned:
    - Code:
      const cars = ["Saab", "Volvo", "BMW"];

      // You can change an element:
      cars[0] = "Toyota";
  - Assigned when Declared:
    JavaScript const variables must be assigned a value when they are declared.
    Meaning: An array declared with const must be initialized when it is declared.
    Using const without initializing the array is a syntax error:
    - Code: 
      const cars;
      cars = ["Saab", "Volvo", "BMW"]; //Not work!

An array declared with var does not have block scope.
Redeclaring Arrays:
  - Redeclaring an array declared with var is allowed anywhere in a program.
  - Redeclaring or reassigning an array to const, in the same scope, or in the same block, is not allowed:
  - Redeclaring an array with const, in another scope, or in another block, is allowed:

----------------------JavaScript Date Objects----------------------------------
NOTE:
  - Date objects are static. The "clock" is not "running".
    The computer clock is ticking, date objects are not.
  - JavaScript counts months from 0 to 11:
      January = 0.
      December = 11.
    
JavaScript Date Output:
  - By default, JavaScript will use the browser's time zone and display a date as a full text string.
Creating Date Objects:
  - Date objects are created with the new Date() constructor.
    There are 9 ways to create a new date object:
    new Date()
    new Date(date string)
    new Date(year,month)
    new Date(year,month,day)
    new Date(year,month,day,hours)
    new Date(year,month,day,hours,minutes)
    new Date(year,month,day,hours,minutes,seconds) 
    new Date(year,month,day,hours,minutes,seconds,ms)
    new Date(milliseconds)

  - new Date() creates a date object with the current date and time:
  - new Date(date string) creates a date object from a date string:
  - new Date(year, month, ...) creates a date object with a specified date and time.
  - You cannot omit month. If you supply only one parameter it will be treated as milliseconds.
Previous Century:
  - One and two digit years will be interpreted as 19xx:
      - const d = new Date(99, 11, 24);

new Date(milliseconds):
  - new Date(milliseconds) creates a new date object as milliseconds plus zero time:
  - NOTE:
  |   - JavaScript stores dates as number of milliseconds since January 01, 1970.

Displaying Dates:
  - toDateString() method converts a date to a more readable format:
  - toUTCString() method converts a date to a string using the UTC standard:
  - toISOString() method converts a date to a string using the ISO standard:

----------------------------JavaScript Date Input----------------------------------
There are generally 3 types of JavaScript date input formats:
  - ISO Date	"2015-03-25" (The International Standard)
    Short Date	"03/25/2015"
    Long Date	"Mar 25 2015" or "25 Mar 2015"

JavaScript ISO Dates:
  - ISO 8601 is the international standard for the representation of dates and times.
    The ISO 8601 syntax (YYYY-MM-DD) is also the preferred JavaScript date format.
  - ISO dates can be written without specifying the day (YYYY-MM):
  - ISO dates can be written without month and day (YYYY):
  - ISO dates can be written with added hours, minutes, and seconds (YYYY-MM-DDTHH:MM:SSZ):
      - Date and time is separated with a capital T.
        UTC time is defined with a capital letter Z.
        If you want to modify the time relative to UTC, remove the Z and add +HH:MM or -HH:MM instead:

-------------------JavaScript Set Date Methods-----------------------------------------
Set Date Methods:
  - setDate()	Set the day as a number (1-31)
    setFullYear()	Set the year (optionally month and day)
    setHours()	Set the hour (0-23)
    setMilliseconds()	Set the milliseconds (0-999)
    setMinutes()	Set the minutes (0-59)
    setMonth()	Set the month (0-11)
    setSeconds()	Set the seconds (0-59)
    setTime()	Set the time (milliseconds since January 1, 1970)

------------------JavaScript Math Object---------------------------------------------
Math Properties (Constants):
  - Math.E        // returns Euler's number
    Math.PI       // returns PI
    Math.SQRT2    // returns the square root of 2
    Math.SQRT1_2  // returns the square root of 1/2
    Math.LN2      // returns the natural logarithm of 2
    Math.LN10     // returns the natural logarithm of 10
    Math.LOG2E    // returns base 2 logarithm of E
    Math.LOG10E   // returns base 10 logarithm of E
Math Methods: 
  - Math.round(x)	Returns x rounded to its nearest integer
    Math.ceil(x)	Returns x rounded up to its nearest integer 
    Math.floor(x)	Returns x rounded down to its nearest integer
    Math.trunc(x)	Returns the integer part of x (new in ES6)
    Math.pow(x, y) returns the value of x to the power of y:
    Math.sqrt(x) returns the square root of x:
    Math.log(x) returns the natural logarithm of x.
    Math.log2(x) returns the base 2 logarithm of x.
    Math.log10(x) returns the base 10 logarithm of x.
    abs(x)	Returns the absolute value of x
    acos(x)	Returns the arccosine of x, in radians
    acosh(x)	Returns the hyperbolic arccosine of x
    asin(x)	Returns the arcsine of x, in radians
    asinh(x)	Returns the hyperbolic arcsine of x
    atan(x)	Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians
    atan2(y, x)	Returns the arctangent of the quotient of its arguments
    atanh(x)	Returns the hyperbolic arctangent of x
    cbrt(x)	Returns the cubic root of x
    ceil(x)	Returns x, rounded upwards to the nearest integer
    cos(x)	Returns the cosine of x (x is in radians)
    cosh(x)	Returns the hyperbolic cosine of x
    exp(x)	Returns the value of Ex
    floor(x)	Returns x, rounded downwards to the nearest integer
    log(x)	Returns the natural logarithm (base E) of x
    max(x, y, z, ..., n)	Returns the number with the highest value
    min(x, y, z, ..., n)	Returns the number with the lowest value
    pow(x, y)	Returns the value of x to the power of y
    random()	Returns a random number between 0 and 1
    round(x)	Rounds x to the nearest integer
    sign(x)	Returns if x is negative, null or positive (-1, 0, 1)
    sin(x)	Returns the sine of x (x is in radians)
    sinh(x)	Returns the hyperbolic sine of x
    sqrt(x)	Returns the square root of x
    tan(x)	Returns the tangent of an angle
    tanh(x)	Returns the hyperbolic tangent of a number
    trunc(x)	Returns the integer part of a number (x)
    Math.random() returns a random number between 0 (inclusive),  and 1 (exclusive):
      - Math.random() returns a random number between 0 (inclusive),  and 1 (exclusive):

-----------------------JavaScript Booleans-------------------------------
Boolean Values:
  - Boolean() function to find out if an expression (or a variable) is true:
  - Everything With a "Value" is True:
      - Boolean(100)
        Boolean(3.14)
        Boolean(-15)
  - Comparing two JavaScript objects always return false.

---------------------JavaScript Comparison and Logical Operators------------
Comparison and Logical operators are used to test for true or false.
Comparison Operators:
  ==	equal to
  ===	equal value and equal type
  !=	not equal
  !==	not equal value or not equal type
  >	greater than
  <	less than	
  >=	greater than or equal to
  <=	less than or equal to

Logical Operators:
  &&	and	(x < 10 && y > 1) is true	
  ||	or	(x == 5 || y == 5) is false	
  !	not	!(x == y) is true

Conditional (Ternary) Operator:
  - Syntax:
      - variablename = (condition) ? value1:value2 
      - let voteable = (age < 18) ? "Too young":"Old enough";
The Nullish Coalescing Operator (??):
  - The ?? operator returns the first argument if it is not nullish (null or undefined).
    Otherwise it returns the second argument:
    let name = null;
    let text = "missing";
    let result = name ?? text;

The Optional Chaining Operator (?.):
The ?. operator returns undefined if an object is undefined or null (instead of throwing an error).
  - // Create an object:
    const car = {type:"Fiat", model:"500", color:"white"};
    // Ask for car name:
    document.getElementById("demo").innerHTML = car?.name;

--------------------JavaScript if, else, and else if--------------------
In JavaScript we have the following conditional statements:
  - Use if to specify a block of code to be executed, if a specified condition is true
    Use else to specify a block of code to be executed, if the same condition is false
    Use else if to specify a new condition to test, if the first condition is false
    Use switch to specify many alternative blocks of code to be executed

-------------------JavaScript Switch Statement------------------------
Note: If you omit the break statement, the next case will be executed even if the evaluation does not match the case.
The default keyword specifies the code to run if there is no case match:
  - If default is not the last case in the switch block, remember to end the default case with a break.

Switching Details:
  - If multiple cases matches a case value, the first case is selected.
  - If no matching cases are found, the program continues to the default label.
  - If no default label is found, the program continues to the statement(s) after the switch.

-------------------JavaScript For Loop----------------------------
JavaScript supports different kinds of loops:
  - for - loops through a block of code a number of times
  - for/in - loops through the properties of an object
  - for/of - loops through the values of an iterable object
  - while - loops through a block of code while a specified condition is true
  - do/while - also loops through a block of code while a specified condition is true

From the example above, you can read:
  - Expression 1 sets a variable before the loop starts (let i = 0).
  - Expression 2 defines the condition for the loop to run (i must be less than 5).
  - Expression 3 increases a value (i++) each time the code block in the loop has been executed.

  - Expression 1:
    - Normally you will use expression 1 to initialize the variable used in the loop (let i = 0).
      This is not always the case. JavaScript doesn't care. Expression 1 is optional.
      You can initiate many values in expression 1 (separated by comma):
        for (let i = 0, len = cars.length, text = ""; i < len; i++) {
               text += cars[i] + "<br>";
        }
    - And you can omit expression 1 (like when your values are set before the loop starts):
      let i = 2;
      let len = cars.length;
      let text = "";
      for (; i < len; i++) {
      text += cars[i] + "<br>";
      }
  - Expression 2:
    - Often expression 2 is used to evaluate the condition of the initial variable.
      This is not always the case. JavaScript doesn't care. Expression 2 is also optional.
      If expression 2 returns true, the loop will start over again. If it returns false, the loop will end.
    - NOTE:
      - If you omit expression 2, you must provide a break inside the loop. 
        Otherwise the loop will never end. This will crash your browser.
         Read about breaks in a later chapter of this tutorial.
    - Expression 3:
      - Often expression 3 increments the value of the initial variable.
        This is not always the case. JavaScript doesn't care. Expression 3 is optional.
        Expression 3 can do anything like negative increment (i--), positive increment (i = i + 15), or anything else.
        Expression 3 can also be omitted (like when you increment your values inside the loop):
          let i = 0;
          let len = cars.length;
          let text = "";
          for (; i < len; ) {
            text += cars[i] + "<br>";
            i++;
          }

---------------------------The For In Loop---------------------------------------
- The JavaScript for in statement loops through the properties of an Object:
  Syntax:
    for (key in object) {
    // code block to be executed
    }

- The JavaScript for in statement can also loop over the properties of an Array:
  for (variable in array) {
  code
  }
- NOTE:
  - Do not use for in over an Array if the index order is important.
    The index order is implementation-dependent, and array values may not be accessed in the order you expect.
    It is better to use a for loop, a for of loop, or Array.forEach() when the order is important.

-----------------------------JavaScript For Of---------------------------------
The JavaScript for of statement loops through the values of an iterable object.
It lets you loop over iterable data structures such as Arrays, Strings, Maps, NodeLists, and more:
  - for (variable of iterable) {
    // code block to be executed
    }
variable - For every iteration the value of the next property is assigned to the variable.
Variable can be declared with const, let, or var.
iterable - An object that has iterable properties.

------------------------------JavaScript While Loop--------------------------------------
The While Loop:
  - The while loop loops through a block of code as long as a specified condition is true.
  - Syntax:
      while (condition) {
      // code block to be executed
      }

---------------------------JavaScript Iterables------------------------------------------
Iterables are iterable objects (like Arrays).
Iterables can be accessed with simple and efficient code.
Iterables can be iterated over with for..of loops
Iterating:
  - terating is easy to understand.
    It simply means looping over a sequence of elements.
    Here are some easy examples:
      - Iterating over a String
        Iterating over an Array

---------------------------JavaScript Sets-----------------------------------------------
Defination:
  - A JavaScript Set is a collection of unique values.
    Each value can only occur once in a Set.

Essential Set Methods:
  - new Set()	Creates a new Set
    add()	Adds a new element to the Set
    delete()	Removes an element from a Set
    has()	Returns true if a value exists in the Set
    forEach()	Invokes a callback for each element in the Set
    values()	Returns an iterator with all the values in a Set
    Property	Description:
      - size	Returns the number of elements in a Set
Set iteration:
  - The values() Method:
    - let text = "";
      for (const x of letters.values()) {
        text += x;
      }

  - The forEach() Method:
    - // Create a Set
      const letters = new Set(["a","b","c"]);

      // List all Elements
      let text = "";
      letters.forEach (function(value) {
      text += value;
    })

----------------------------JavaScript Maps---------------------------------------
NOTE:
  - A Map holds key-value pairs where the keys can be any datatype.
    A Map remembers the original insertion order of the keys.
  - Essential Map Methods:
    - Method	Description
        new Map()	Creates a new Map
        set()	Sets the value for a key in a Map:
          - set() method can also be used to change existing Map values.
        get()	Gets the value for a key in a Map
        delete()	Removes a Map element specified by the key
        has()	Returns true if a key exists in a Map
        forEach()	Calls a function for each key/value pair in a Map
        entries()	Returns an iterator with the [key, value] pairs in a Map
        Property	Description
        size	Returns the number of elements in a Map
JavaScript Objects vs Maps:
                  Object	                            Map
    Iterable    	Not directly iterable	              Directly iterable
    Size	        Do not have a size property	        Have a size property
    Key Types    	Keys must be Strings (or Symbols)  	Keys can be any datatype
    Key Order	    Keys are not well ordered          	Keys are ordered by insertion
    Defaults	    Have default keys                 	Do not have default keys
The forEach() Method:
  - // List all entries
    let text = "";
    fruits.forEach (function(value, key) {
      text += key + ' = ' + value;
    })

---------------------------JavaScript typeof------------------------------------------
In JavaScript there are 5 different data types that can contain values:
  - string
    number
    boolean
    object
    function
There are 6 types of objects:
  - Object
    Date
    Array
    String
    Number
    Boolean
2 data types that cannot contain values:
  - null:
      - In JavaScript null is "nothing". It is supposed to be something that doesn't exist.
        Unfortunately, in JavaScript, the data type of null is an object.
      - You can consider it a bug in JavaScript that typeof null is an object. It should be null.

    undefined:
      - Any variable can be emptied, by setting the value to undefined. The type will also be undefined.
    Difference Between Undefined and Null:
        undefined and null are equal in value but different in type:
      - typeof undefined           // undefined
        typeof null                // object

    null === undefined         // false
    null == undefined          // true
Please observe:
  - The data type of NaN is number
    The data type of an array is object
    The data type of a date is object
    The data type of null is object
    The data type of an undefined variable is undefined *
   The data type of a variable that has not been assigned a value is also undefined *
NOTE:  You cannot use typeof to determine if a JavaScript object is an array (or a date).

Primitive Data:
  - A primitive data value is a single simple data value with no additional properties and methods.
    The typeof operator can return one of these primitive types:
      - string
        number
        boolean
        undefined
Complex Data:
  - The typeof operator can return one of two complex types:
      function
      object
  - The typeof operator returns "object" for objects, arrays, and null.
    The typeof operator does not return "object" for functions.
  - The typeof operator returns "object" for arrays because in JavaScript arrays are objects.
The constructor Property:
The constructor property returns the constructor function for all JavaScript variables.
"John".constructor                // Returns function String()  {[native code]}
(3.14).constructor                // Returns function Number()  {[native code]}
false.constructor                 // Returns function Boolean() {[native code]}
[1,2,3,4].constructor             // Returns function Array()   {[native code]}
{name:'John',age:34}.constructor  // Returns function Object()  {[native code]}
new Date().constructor            // Returns function Date()    {[native code]}
function () {}.constructor        // Returns function Function(){[native code]}

You can check the constructor property to find out if an object is an Array (contains the word "Array"):
  - function isArray(myArray) {
  return myArray.constructor.toString().indexOf("Array") > -1;
}
Or even simpler, you can check if the object is an Array function:
  - function isArray(myArray) {
  return myArray.constructor === Array;
}
ou can check the constructor property to find out if an object is a Date (contains the word "Date"):
  - function isDate(myDate) {
      return myDate.constructor.toString().indexOf("Date") > -1;
    }

The instanceof Operator:
  - The instanceof operator returns true if an object is an instance of the specified object:

The void Operator:
  - The void operator evaluates an expression and returns undefined. 
  This operator is often used to obtain the undefined primitive value, 
  using "void(0)" (useful when evaluating an expression without using the return value).

--------------------------------JavaScript Type Conversion------------------------------------
JavaScript variables can be converted to a new variable and another data type:
  - By the use of a JavaScript function
    Automatically by JavaScript itself
Converting Strings to Numbers:
  - The global method Number() converts a variable (or a value) into a number.
    A numeric string (like "3.14") converts to a number (like 3.14).
    An empty string (like "") converts to 0.
    A non numeric string (like "John") converts to NaN (Not a Number).
Number Methods:
  - Number()	Returns a number, converted from its argument
    parseFloat()	Parses a string and returns a floating point number
    parseInt()	Parses a string and returns an integer
The Unary + Operator:
  - The unary + operator can be used to convert a variable to a number:
    let y = "5";      // y is a string
    let x = + y;      // x is a number
Converting Numbers to Strings:
  - The global method String() can convert numbers to strings.
    It can be used on any type of numbers, literals, variables, or expressions:
More Methods:
  - toExponential()	Returns a string, with a number rounded and written using exponential notation.
    toFixed()	Returns a string, with a number rounded and written with a specified number of decimals.
    toPrecision()	Returns a string, with a number written with a specified length
Automatic Type Conversion:
  - When JavaScript tries to operate on a "wrong" data type, it will try to convert the value to a "right" type.
    The result is not always what you expect:
    5 + null    // returns 5         because null is converted to 0
    "5" + null  // returns "5null"   because null is converted to "null"
    "5" + 2     // returns "52"      because 2 is converted to "2"
    "5" - 2     // returns 3         because "5" is converted to 5
    "5" * "2"   // returns 10        because "5" and "2" are converted to 5 and 2

-------------------------JavaScript Bitwise Operations--------------------------------
JavaScript Bitwise Operators:
  - &	AND	Sets each bit to 1 if both bits are 1
    |	OR	Sets each bit to 1 if one of two bits is 1
    ^	XOR	Sets each bit to 1 if only one of two bits is 1
    ~	NOT	Inverts all the bits
    <<	Zero fill left shift	Shifts left by pushing zeros in from the right and let the leftmost bits fall off
    >>	Signed right shift	Shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off
    >>>	Zero fill right shift	Shifts right by pushing zeros in from the left, and let the rightmost bits fall off
JavaScript Uses 32 bits Bitwise Operands:

-------------------------JavaScript Regular Expressions--------------------------------------------------
A regular expression is a sequence of characters that forms a search pattern.
The search pattern can be used for text search and text replace operations.
What Is a Regular Expression?:
  - A regular expression is a sequence of characters that forms a search pattern.
    When you search for data in a text, you can use this search pattern to describe what you are searching for.
    A regular expression can be a single character, or a more complicated pattern.
    Regular expressions can be used to perform all types of text search and text replace operations.
Syntax:
  - /pattern/modifiers;
Example:
  - /w3schools/i;
  Example explained:
    - /w3schools/i  is a regular expression.
    - w3schools  is a pattern (to be used in a search).
    - i  is a modifier (modifies the search to be case-insensitive).
Using String Methods:
  - In JavaScript, regular expressions are often used with the two string methods: search() and replace().
  - The search() method uses an expression to search for a match, and returns the position of the match.
  - The replace() method returns a modified string where the pattern is replaced.
Did You Notice? :
  - Regular expression arguments (instead of string arguments) can be used in the methods above.
  - Regular expressions can make your search much more powerful (case insensitive for example).
Regular Expression Modifiers:
  - Modifier                   	Description	Try it
    i	                          Perform case-insensitive matching	
    g	                          Perform a global match (find all matches rather than stopping after the first match)	
    m	                          Perform multiline matching
Regular Expression Patterns:
- Brackets are used to find a range of characters:
  - Expression	       Description	Try it
    [abc]	             Find any of the characters between the brackets	
    [0-9]	             Find any of the digits between the brackets	
    (x|y)	             Find any of the alternatives separated with |
- Metacharacters are characters with a special meaning:
  - Metacharacter	                 Description	Try it
    \d	                           Find a digit	
    \s	                           Find a whitespace character	
    \b	                           Find a match at the beginning of a word like this: \bWORD, or at the end of a word like this: WORD\b	
    \uxxxx	                       Find the Unicode character specified by the hexadecimal number xxxx
 - Quantifiers define quantities:
   - Quantifier	                   Description	Try it
     n+	                           Matches any string that contains at least one n
     n*	                           Matches any string that contains zero or more occurrences of n
     n?	                           Matches any string that contains zero or one occurrences of n
Note:
  - You don't have to put the regular expression in a variable first. The two lines above can be shortened to one:
    /e/.test("The best things in life are free!");
Using exec():
  - The exec() method is a RegExp expression method:
    - t searches a string for a specified pattern, and returns the found text as an object.
      If no match is found, it returns an empty (null) object.
      The following example searches a string for the character "e":

----------------------------JavaScript Operator Precedence-----------------------------------------------------
Explantation:
  - Operator precedence describes the order in which operations are performed in an arithmetic expression.
  - Multiplication (*) and division (/) have higher precedence than addition (+) and subtraction (-).
    - As in traditional mathematics, multiplication is done first:
      let x = 100 + 50 * 3;
  

----------------------------JavaScript Errors-----------------------------------------
Throw, and Try...Catch...Finally:
  - The try statement defines a code block to run (to try).
  - The catch statement defines a code block to handle any error.
  - The finally statement defines a code block to run regardless of the result.
  - The throw statement defines a custom error.
Try:
  - The try statement allows you to define a block of code to be tested for errors while it is being executed.
Catch:
  - The catch statement allows you to define a block of code to be executed, if an error occurs in the try block.
JavaScript Throws Errors:
  - JavaScript will actually create an Error object with two properties: name and message.
The throw Statement:
  - The throw statement allows you to create a custom error.
    Technically you can throw an exception (throw an error).
    The exception can be a JavaScript String, a Number, a Boolean or an Object:
  - If you use throw together with try and catch, you can control program flow 
    and generate custom error messages.
The finally Statement:
  - The finally statement lets you execute code, after try and catch, regardless of the result:
      try {
        Block of code to try
      }catch(err) { 
        Block of code to handle errors
      } finally { 
        Block of code to be executed regardless of the try / catch result
      }
The Error Object:
  - JavaScript has a built in error object that provides error information when an error occurs.
    The error object provides two useful properties: name and message.
    Error Object Properties:
      - name	Sets or returns an error name
      - message	Sets or returns an error message (a string)
    - Error Name Values:
        - EvalError	An error has occurred in the eval() function
          RangeError	A number "out of range" has occurred
          ReferenceError	An illegal reference has occurred
          SyntaxError	A syntax error has occurred
          TypeError	A type error has occurred
          URIError	An error in encodeURI() has occurred
  - Eval Error:
      - An EvalError indicates an error in the eval() function.
      - Newer versions of JavaScript do not throw EvalError. Use SyntaxError instead.
  - Range Error:
      - A RangeError is thrown if you use a number that is outside the range of legal values.
  - Reference Error:
      - A ReferenceError is thrown if you use (reference) a variable that has not been declared:
  - Syntax Error:
      - A SyntaxError is thrown if you try to evaluate code with a syntax error.
  - Type Error:
      - A TypeError is thrown if you use a value that is outside the range of expected types:
  - URI (Uniform Resource Identifier) Error:
      - A URIError is thrown if you use illegal characters in a URI function:
Non-Standard Error Object Properties:
  - Mozilla and Microsoft define some non-standard error object properties:
    fileName (Mozilla)
    lineNumber (Mozilla)
    columnNumber (Mozilla)
    stack (Mozilla)
    description (Microsoft)
    number (Microsoft)
    Do not use these properties in public web sites. They will not work in all browsers.

-------------------------------JavaScript Scope---------------------------------------
Scope determines the accessibility (visibility) of variables.
JavaScript has 3 types of scope:
  - Block scope
    Function scope
    Global scope
Block Scope:
  - ES6 introduced two important new JavaScript keywords: let and const.
    These two keywords provide Block Scope in JavaScript.
    Variables declared inside a { } block cannot be accessed from outside the block:
    Example
    {
      let x = 2;
    } // x can NOT be used here
    Note: Variables declared with the var keyword can NOT have block scope.
Automatically Global:
  - If you assign a value to a variable that has not been declared, it will automatically become a GLOBAL variable.
  - In "Strict Mode", undeclared variables are not automatically global.
Global Variables in HTML:
  - Global variables defined with the var keyword belong to the window object.
  - Global variables defined with the let keyword do not belong to the window object.
  - Warning:
      - Do NOT create global variables unless you intend to.
        Your global variables (or functions) can overwrite window variables (or functions).
        Any function, including the window object, can overwrite your global variables and functions.
The Lifetime of JavaScript Variables:
  - The lifetime of a JavaScript variable starts when it is declared.
  - Function (local) variables are deleted when the function is completed.
  - In a web browser, global variables are deleted when you close the browser window (or tab).
Function Arguments:
  - Function arguments (parameters) work as local variables inside functions.

-----------------------------JavaScript Hoisting-------------------------------------------
- Hoisting is JavaScript's default behavior of moving declarations to the top.
JavaScript Declarations are Hoisted:
  - In JavaScript, a variable can be declared after it has been used.
    In other words; a variable can be used before it has been declared.
  - Hoisting is JavaScript's default behavior of moving all declarations to the top of the
    current scope (to the top of the current script or the current function).
The let and const Keywords:
  - Variables defined with let and const are hoisted to the top of the block, but not initialized.
  - Meaning: The block of code is aware of the variable, but it cannot be used until it has been declared.
JavaScript Initializations are Not Hoisted:
  - JavaScript only hoists declarations, not initializations.
Declare Your Variables At the Top !:
  - Hoisting is (to many developers) an unknown or overlooked behavior of JavaScript.
    If a developer doesn't understand hoisting, programs may contain bugs (errors).
    To avoid bugs, always declare all variables at the beginning of every scope.
    Since this is how JavaScript interprets the code, it is always a good rule.

--------------------------JavaScript Use Strict----------------------------------------------
- "use strict"; Defines that JavaScript code should be executed in "strict mode".
  The "use strict" directive was new in ECMAScript version 5.
  It is not a statement, but a literal expression, ignored by earlier versions of JavaScript.
  The purpose of "use strict" is to indicate that the code should be executed in "strict mode".
  With strict mode, you can not, for example, use undeclared variables.
Declaring Strict Mode:
  - Strict mode is declared by adding "use strict"; to the beginning of a script or a function.
Not Allowed in Strict Mode:
  - Using a variable, without declaring it, is not allowed:
    "use strict";
    x = 3.14;                // This will cause an error
  - Objects are variables too.
    Using an object, without declaring it, is not allowed:
    "use strict";
    x = {p1:10, p2:20};      // This will cause an error
  - Deleting a variable (or object) is not allowed.
    "use strict";
    let x = 3.14;
    delete x;      
  - Deleting a function is not allowed.
    "use strict";
    function x(p1, p2) {};
    delete x;                // This will cause an error 
  - Duplicating a parameter name is not allowed:
    "use strict";
    function x(p1, p1) {};   // This will cause an error
  - Octal numeric literals are not allowed:
    "use strict";
    let x = 010;             // This will cause an error
  - Octal escape characters are not allowed:
    "use strict";
    let x = "\010";            // This will cause an error
  - Writing to a read-only property is not allowed:
    "use strict";
    const obj = {};
    Object.defineProperty(obj, "x", {value:0, writable:false});
    obj.x = 3.14;            // This will cause an error
  - Writing to a get-only property is not allowed:
    "use strict";
    const obj = {get x() {return 0} };
    obj.x = 3.14;            // This will cause an error
  - Deleting an undeletable property is not allowed:
    "use strict";
    delete Object.prototype; // This will cause an error
  - The word eval cannot be used as a variable:
    "use strict";
    let eval = 3.14;         // This will cause an error
  - The word arguments cannot be used as a variable:
    "use strict";
    let arguments = 3.14;    // This will cause an error
  - The with statement is not allowed:
    "use strict";
    with (Math){x = cos(2)}; // This will cause an error
  - For security reasons, eval() is not allowed to create variables in the scope from which it was called.
    In strict mode, a variable can not be used before it is declared:
    "use strict";
    eval ("x = 2");
    alert (x);      // This will cause an error 
  - In strict mode, eval() can not declare a variable using the var keyword:
    "use strict";
    eval ("var x = 2");
    alert (x);    // This will cause an error
  - eval() can not declare a variable using the let keyword:
    eval ("let x = 2");
    alert (x);        // This will cause an error
  - The this keyword in functions behaves differently in strict mode.
    The this keyword refers to the object that called the function.
    If the object is not specified, functions in strict mode will return undefined and functions in normal mode will return the global object (window):
    "use strict";
    function myFunction() {
      alert(this); // will alert "undefined"
      }
    myFunction();
Future Proof!:
  - Keywords reserved for future JavaScript versions can NOT be used as variable names in strict mode.
    These are:
    implements
    interface
    let
    package
    private
    protected
    public
    static
    yield
    "use strict";
    let public = 1500;      // This will cause an error
Watch Out!:
  - The "use strict" directive is only recognized at the beginning of a script or a function.

  ----------------------------The JavaScript this Keyword--------------------------------------------
  What is this?:
    - In JavaScript, the this keyword refers to an object.
      Which object depends on how this is being invoked (used or called).
      The this keyword refers to different objects depending on how it is used:
    - In an object method, this refers to the object.
      Alone, this refers to the global object.
      In a function, this refers to the global object.
      In a function, in strict mode, this is undefined.
      In an event, this refers to the element that received the event.
      Methods like call(), apply(), and bind() can refer this to any object.
Note:
  - this is not a variable. It is a keyword. You cannot change the value of this.
this in a Method:
  - When used in an object method, this refers to the object.
this Alone:
  - When used alone, this refers to the global object.
this in a Function (Default):
  - In a function, the global object is the default binding for this.
this in a Function (Strict):
  - JavaScript strict mode does not allow default binding.
    So, when used in a function, in strict mode, this is undefined.
      - "use strict";
        function myFunction() {
          return this;
        }
this in Event Handlers:
  - In HTML event handlers, this refers to the HTML element that received the event:
      - <button onclick="this.style.display='none'">
          Click to Remove Me!
        </button>
Function Borrowing:
  - With the bind() method, an object can borrow a method from another object.
    This example creates 2 objects (person and member).
    The member object borrows the fullname method from the person object:
This Precedence:
  - To determine which object this refers to; use the following precedence of order.
    1	bind()
    2	apply() and call()
    3	Object method
    4	Global scope

------------------------------JavaScript Arrow Function--------------------------------------
Arrow functions allow us to write shorter function syntax:
  - let myFunction = (a, b) => a * b;
NOTE:
  - It gets shorter! If the function has only one statement,
    and the statement returns a value, you can remove the brackets and the return keyword:
      - hello = () => "Hello World!";
  Note: Note: This works only if the function has only one statement.
  - If you have parameters, you pass them inside the parentheses:
    - hello = (val) => "Hello " + val;
  - In fact, if you have only one parameter, you can skip the parentheses as well:
    - hello = val => "Hello " + val;
What About this?:
  - The handling of this is also different in arrow functions compared to regular functions.
    In short, with arrow functions there are no binding of this.
    In regular functions the this keyword represented the object that called the function,
    which could be the window, the document, a button or whatever.
    With arrow functions the this keyword always represents the object that defined the arrow function.
  - Note:
    - Remember these differences when you are working with functions. 
      Sometimes the behavior of regular functions is what you want, if not, use arrow functions.

-------------------------------JavaScript Classes-----------------------------------------------
ECMAScript 2015, also known as ES6, introduced JavaScript Classes.
JavaScript Classes are templates for JavaScript Objects.
JavaScript Class Syntax:
  - Use the keyword class to create a class.
    Always add a method named constructor():
      - class ClassName {
          constructor() { ... }
        }
Note:
  - A JavaScript class is not an object.It is a template for JavaScript objects.
The Constructor Method:
  - The constructor method is called automatically when a new object is created.

  - The constructor method is a special method:
    - It has to have the exact name "constructor"
      It is executed automatically when a new object is created
      It is used to initialize object properties

    - If you do not define a constructor method, JavaScript will add an empty constructor method.

Class Methods:
  - Class methods are created with the same syntax as object methods.
    Use the keyword class to create a class.
    Always add a constructor() method.
  - Syntax:
    class ClassName { 
      constructor() { ... }
      method_1() { ... }
      method_2() { ... }
      method_3() { ... }
    }

---------------------------------JavaScript Modules---------------------------------------------
Modules:
  - JavaScript modules allow you to break up your code into separate files.
    This makes it easier to maintain a code-base.
    Modules are imported from external files with the import statement.
    Modules also rely on type="module" in the <script> tag.
    Example:
      <script type="module">
        import message from "./message.js";
      </script>
Export:
  - Modules with functions or variables can be stored in any external file.
    There are two types of exports: Named Exports and Default Exports.
  - Named Exports:
    - Let us create a file named person.js, and fill it with the things we want to export.
      You can create named exports two ways. In-line individually, or all at once at the bottom.
      In-line individually:
        - person.js
          export const name = "Jesse";
          export const age = 40;
      All at once at the bottom:
        - person.js
          const name = "Jesse";
          const age = 40;
          export {name, age};
  - Default Exports:
    - Let us create another file, named message.js, and use it for demonstrating default export.

Import:
  - You can import modules into a file in two ways, based on if they are named exports or default exports.
    Named exports are constructed using curly braces. Default exports are not.
    Import from named exports:
      - Import named exports from the file person.js:
        - import { name, age } from "./person.js";
    Import from default exports:
      - Import a default export from the file message.js:
        - import message from "./message.js";

------------------------------JavaScript JSON-------------------------------------------------------
JSON is a format for storing and transporting data.
JSON is often used when data is sent from a server to a web page.
What is JSON?:
  - JSON stands for JavaScript Object Notation
    JSON is a lightweight data interchange format
    JSON is language independent *
    JSON is "self-describing" and easy to understand

  - * The JSON syntax is derived from JavaScript object notation syntax,
     but the JSON format is text only. Code for reading and generating JSON
      data can be written in any programming language.
JSON Example:
  - This JSON syntax defines an employees object: an array of 3 employee records (objects):
    - JSON Example:
      - {
        "employees":[
          {"firstName":"John", "lastName":"Doe"},
          {"firstName":"Anna", "lastName":"Smith"},
          {"firstName":"Peter", "lastName":"Jones"}
         ]
        }
The JSON Format Evaluates to JavaScript Objects:
  - The JSON format is syntactically identical to the code for creating JavaScript objects.
  - Because of this similarity, a JavaScript program can easily convert JSON data into native JavaScript objects.
JSON Syntax Rules:
 - Data is in name/value pairs
   Data is separated by commas
  Curly braces hold objects
  Square brackets hold arrays
JSON Data - A Name and a Value:
  - JSON data is written as name/value pairs, just like JavaScript object properties.
  - A name/value pair consists of a field name (in double quotes), followed by a colon, followed by a value:
    - "firstName":"John"
NOTE: - JSON names require double quotes. JavaScript names do not.
JSON Objects:
  - JSON objects are written inside curly braces.
  - Just like in JavaScript, objects can contain multiple name/value pairs:
    - {"firstName":"John", "lastName":"Doe"}; 
JSON Arrays:
  - JSON arrays are written inside square brackets.
  - Just like in JavaScript, an array can contain objects:
    - "employees":[
      {"firstName":"John", "lastName":"Doe"},
      {"firstName":"Anna", "lastName":"Smith"},
      {"firstName":"Peter", "lastName":"Jones"}
      ]
Converting a JSON Text to a JavaScript Object:
  - A common use of JSON is to read data from a web server, and display the data in a web page.
  - For simplicity, this can be demonstrated using a string as input.
  - First, create a JavaScript string containing JSON syntax:
    - let text = '{ "employees" : [' +
      '{ "firstName":"John" , "lastName":"Doe" },' +
      '{ "firstName":"Anna" , "lastName":"Smith" },' +
      '{ "firstName":"Peter" , "lastName":"Jones" } ]}';

-------------------------------JavaScript Debugging---------------------------------------------
Code Debugging:
  - Programming code might contain syntax errors, or logical errors.
    Many of these errors are difficult to diagnose.
    Often, when programming code contains errors, nothing will happen. There are no error messages, and you will get no indications where to search for errors.
    Searching for (and fixing) errors in programming code is called code debugging.

JavaScript Debuggers:
  - Debugging is not easy. But fortunately, all modern browsers have a built-in JavaScript debugger.
    With a debugger, you can also set breakpoints (places where code execution can be stopped), 
    and examine variables while the code is executing.
    Normally (otherwise follow the steps at the bottom of this page),
     you activate debugging in your browser with the F12 key, and select "Console" in the debugger menu.
  - Setting Breakpoints:
    - In the debugger window, you can set breakpoints in the JavaScript code.
      At each breakpoint, JavaScript will stop executing, and let you examine JavaScript values.
      After examining values, you can resume the execution of code (typically with a play button).
  - The debugger Keyword:
    - The debugger keyword stops the execution of JavaScript, and calls (if available) the debugging function.
      This has the same function as setting a breakpoint in the debugger.
      If no debugging is available, the debugger statement has no effect.
      With the debugger turned on, this code will stop executing before it executes the third line.
  - Debugging is the process of testing, finding, and reducing bugs (errors) in computer programs.
    The first known computer bug was a real bug (an insect) stuck in the electronics.

--------------------------JavaScript Style Guide--------------------------------------------------
JavaScript Coding Conventions:
  - Coding conventions are style guidelines for programming. They typically cover:
    - Naming and declaration rules for variables and functions.
    - Rules for the use of white space, indentation, and comments.
    - Programming practices and principles.
  - Coding conventions secure quality:
    - Improve code readability
    - Make code maintenance easier
Variable Names:
  - At W3schools we use camelCase for identifier names (variables and functions).
    All names start with a letter.
Spaces Around Operators:
  - Always put spaces around operators ( = + - * / ), and after commas:
    - Examples:
      let x = y + z;
      const myArray = ["Volvo", "Saab", "Fiat"];
Code Indentation:
  - Always use 2 spaces for indentation of code blocks:
    - Functions:
      function toCelsius(fahrenheit) {
        return (5 / 9) * (fahrenheit - 32);
      }
    - Do not use tabs (tabulators) for indentation. Different editors interpret tabs differently.
Statement Rules:
  - General rules for simple statements:
    Always end a simple statement with a semicolon.

    const cars = ["Volvo", "Saab", "Fiat"];
    const person = {
    firstName: "John",
    lastName: "Doe",
    age: 50,
    eyeColor: "blue"
    };
  - General rules for complex (compound) statements:
    - Put the opening bracket at the end of the first line.
      Use one space before the opening bracket.
      Put the closing bracket on a new line, without leading spaces.
      Do not end a complex statement with a semicolon.
    - Functions:
      function toCelsius(fahrenheit) {
        return (5 / 9) * (fahrenheit - 32);
      }
    - Loops:
      for (let i = 0; i < 5; i++) {
        x += i;
      }
    - Conditionals:
      if (time < 20) {
        greeting = "Good day";
        } else {
          greeting = "Good evening";
        }
Object Rules:
  - General rules for object definitions:
    - Place the opening bracket on the same line as the object name.
      Use colon plus one space between each property and its value.
      Use quotes around string values, not around numeric values.
      Do not add a comma after the last property-value pair.
      Place the closing bracket on a new line, without leading spaces.
      Always end an object definition with a semicolon.
    - Example:
      const person = {
      firstName: "John",
      lastName: "Doe",
      age: 50,
      eyeColor: "blue"
      };
    - Short objects can be written compressed, on one line, using spaces only between properties, like this:
      const person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};
Line Length < 80:
  - For readability, avoid lines longer than 80 characters.
    If a JavaScript statement does not fit on one line, the best place to break it, is after an operator or a comma.
    Example:
      document.getElementById("demo").innerHTML =
      "Hello Dolly.";
Naming Conventions:
  - Always use the same naming convention for all your code. For example:
    - Variable and function names written as camelCase
      Global variables written in UPPERCASE (We don't, but it's quite common)
      Constants (like PI) written in UPPERCASE
  - Should you use hyp-hens, camelCase, or under_scores in variable names?
    This is a question programmers often discuss. The answer depends on who you ask:
  - Hyphens in HTML and CSS:
    HTML5 attributes can start with data- (data-quantity, data-price).
    CSS uses hyphens in property-names (font-size).
    Note: - Hyphens can be mistaken as subtraction attempts. Hyphens are not allowed in JavaScript names.
  - Underscores:
    - Many programmers prefer to use underscores (date_of_birth), especially in SQL databases.
      Underscores are often used in PHP documentation.
  - PascalCase:
    - PascalCase is often preferred by C programmers.
  - camelCase:
    - camelCase is used by JavaScript itself, by jQuery, and other JavaScript libraries.
    Note: - Do not start names with a $ sign. It will put you in conflict with many JavaScript library names.
Loading JavaScript in HTML:
  - Use simple syntax for loading external scripts (the type attribute is not necessary):
    - <script src="myscript.js"></script>
Accessing HTML Elements:
  - A consequence of using "untidy" HTML styles, might result in JavaScript errors.
    These two JavaScript statements will produce different results:
      - const obj = getElementById("Demo")
        const obj = getElementById("demo")
File Extensions:
  - HTML files should have a .html extension (.htm is allowed).
  - CSS files should have a .css extension.
  - JavaScript files should have a .js extension.
Use Lower Case File Names:
  - Most web servers (Apache, Unix) are case sensitive about file names:
    - london.jpg cannot be accessed as London.jpg.
    - Other web servers (Microsoft, IIS) are not case sensitive:
    - london.jpg can be accessed as London.jpg or london.jpg.
    - If you use a mix of upper and lower case, you have to be extremely consistent.
    - If you move from a case insensitive, to a case sensitive server, even small errors can break your web site.
    - To avoid these problems, always use lower case file names (if possible).
Performance:
  - Coding conventions are not used by computers. Most rules have little impact on the execution of programs.
    Indentation and extra spaces are not significant in small scripts.
    For code in development, readability should be preferred. Larger production scripts should be minimized.

----------------------------------JavaScript Best Practices---------------------------------------------------
Avoid global variables, avoid new, avoid ==, avoid eval()
Avoid Global Variables:
  - Minimize the use of global variables.
    This includes all data types, objects, and functions.
    Global variables and functions can be overwritten by other scripts.
    Use local variables instead, and learn how to use closures.
Always Declare Local Variables:
  - All variables used in a function should be declared as local variables.
  - Local variables must be declared with the var, the let, or the const keyword, otherwise they will become global variables.
  - Strict mode does not allow undeclared variables.
Declarations on Top:
  - It is a good coding practice to put all declarations at the top of each script or function.
  - This will:
    - Give cleaner code
      Provide a single place to look for local variables
      Make it easier to avoid unwanted (implied) global variables
      Reduce the possibility of unwanted re-declarations
Initialize Variables:
  - It is a good coding practice to initialize variables when you declare them.
  - This will:
    - Give cleaner code
      Provide a single place to initialize variables
      Avoid undefined values

      // Declare and initiate at the beginning
       let firstName = "";
       let lastName = "";
       let price = 0;
       let discount = 0;
       let fullPrice = 0,
       const myArray = [];
       const myObject = {};
    - Note: - Initializing variables provides an idea of the intended use (and intended data type).
Declare Objects with const:
  - Declaring objects with const will prevent any accidental change of type:
    - Example:
      let car = {type:"Fiat", model:"500", color:"white"};
      car = "Fiat";      // Changes object to string
    - const car = {type:"Fiat", model:"500", color:"white"};
      car = "Fiat";      // Not possible
Declare Arrays with const:
  - Declaring arrays with const will prevent any accidential change of type:
    - Example:
      let cars = ["Saab", "Volvo", "BMW"];
      cars = 3;    // Changes array to number

    - const cars = ["Saab", "Volvo", "BMW"]; 
      cars = 3;    // Not possible

Don't Use new Object():
  - Use "" instead of new String()
  - Use 0 instead of new Number()
  - Use false instead of new Boolean()
  - Use {} instead of new Object()
  - Use [] instead of new Array()
  - Use /()/ instead of new RegExp()
  - Use function (){} instead of new Function()
Beware of Automatic Type Conversions:
  - JavaScript is loosely typed.
    A variable can contain all data types.
    A variable can change its data type:
    - Example:
      let x = "Hello";     // typeof x is a string
      x = 5;               // changes typeof x to a number
  - Beware that numbers can accidentally be converted to strings or NaN (Not a Number).
    When doing mathematical operations, JavaScript can convert numbers to strings:
    
    let x = 5 + 7;       // x.valueOf() is 12,  typeof x is a number
    let x = 5 + "7";     // x.valueOf() is 57,  typeof x is a string
    let x = "5" + 7;     // x.valueOf() is 57,  typeof x is a string
    let x = 5 - 7;       // x.valueOf() is -2,  typeof x is a number
    let x = 5 - "7";     // x.valueOf() is -2,  typeof x is a number
    let x = "5" - 7;     // x.valueOf() is -2,  typeof x is a number
    let x = 5 - "x";     // x.valueOf() is NaN, typeof x is a number
Note:
  - Subtracting a string from a string, does not generate an error but returns NaN (Not a Number):
    Example:
      "Hello" - "Dolly"    // returns NaN
Use === Comparison:
  - The == comparison operator always converts (to matching types) before comparison.
  - The === operator forces comparison of values and type:
    - Example:
      0 == "";        // true
      1 == "1";       // true
      1 == true;      // true

      0 === "";       // false
      1 === "1";      // false
      1 === true;     // false
Use Parameter Defaults:
  - If a function is called with a missing argument, the value of the missing argument is set to undefined.
    Undefined values can break your code. It is a good habit to assign default values to arguments.
    Example:
    function myFunction(x, y) {
      if (y === undefined) {
      y = 0;
      }
    }
    function (a=1, b=1) { /*function code*/ }
End Your Switches with Defaults:
  - Always end your switch statements with a default. Even if you think there is no need for it.
Avoid Number, String, and Boolean as Objects:
  - Always treat numbers, strings, or booleans as primitive values. Not as objects.
    Declaring these types as objects, slows down execution speed, and produces nasty side effects:
    Example:
      let x = "John";             
      let y = new String("John");
      (x === y) // is false because x is a string and y is an object.
    Or even worse:
      Example:
      let x = new String("John");             
      let y = new String("John");
      (x == y) // is false because you cannot compare objects.
Avoid Using eval():
  - The eval() function is used to run text as code. In almost all cases, it should not be necessary to use it.
    Because it allows arbitrary code to be run, it also represents a security problem.

---------------------------JavaScript Common Mistakes-------------------------------------------------
Accidentally Using the Assignment Operator:
  - JavaScript programs may generate unexpected results if a programmer accidentally uses an assignment 
    operator (=), instead of a comparison operator (==) in an if statement.
    Note: - An assignment always returns the value of the assignment.
Expecting Loose Comparison:
  - In regular comparison, data type does not matter. This if statement returns true:
    let x = 10;
    let y = "10";
    if (x == y)
Confusing Addition & Concatenation:
  - Addition is about adding numbers.
    Concatenation is about adding strings.
    In JavaScript both operations use the same + operator.
    Because of this, adding a number as a number will produce a different result from adding a number as a string:
    let x = 10;
    x = 10 + 5;       // Now x is 15
    
    let y = 10;
    y += "5";        // Now y is "105"
Misunderstanding Floats:
  - All numbers in JavaScript are stored as 64-bits Floating point numbers (Floats).
    All programming languages, including JavaScript, have difficulties with precise floating point values:
      - let x = 0.1;
        let y = 0.2;
        let z = x + y            // the result in z will not be 0.3
    To solve the problem above, it helps to multiply and divide:
      - let z = (x * 10 + y * 10) / 10;       // z will be 0.3
Breaking a JavaScript String:
  - JavaScript will allow you to break a statement into two lines:
    - let x =
        "Hello World!";
  - But, breaking a statement in the middle of a string will not work:
    - let x = "Hello
      World!";
  - You must use a "backslash" if you must break a statement in a string:
    - let x = "Hello \
      World!";
Misplacing Semicolon:
  - Because of a misplaced semicolon, this code block will execute regardless of the value of x:
    - if (x == 19);
    {
      // code block 
    }
Breaking a Return Statement:
  - It is a default JavaScript behavior to close a statement automatically at the end of a line.
    Because of this, these two examples will return the same result:
      - function myFunction(a) {
          let power = 10 
          return a * power
        }

      - function myFunction(a) {
          let power = 10;
          return a * power;
        }
      
  - JavaScript will also allow you to break a statement into two lines.
    Because of this, example 3 will also return the same result:
    - function myFunction(a) {
      let
      power = 10; 
      return a * power;
    }
  - The function will return undefined!
    Why? Because JavaScript thought you meant:
      - function myFunction(a) {
          let
          power = 10; 
          return;
          a * power;
        }
Explanation:
  - If a statement is incomplete like:
    - let
  - JavaScript will try to complete the statement by reading the next line:
    - power = 10;
  - But since this statement is complete:
   - return
  - JavaScript will automatically close it like this:
    - return;
  This happens because closing (ending) statements with semicolon is optional in JavaScript.
  JavaScript will close the return statement at the end of the line, because it is a complete statement.
  NOTE: - Never break a return statement.
Accessing Arrays with Named Indexes:
  - Many programming languages support arrays with named indexes.
    Arrays with named indexes are called associative arrays (or hashes).
    JavaScript does not support arrays with named indexes.
    In JavaScript, arrays use numbered indexes:  
  - In JavaScript, objects use named indexes.
    If you use a named index, when accessing an array, JavaScript will redefine the array to a standard object.
    In JavaScript, objects use named indexes.
    If you use a named index, when accessing an array, JavaScript will redefine the array to a standard object.
Ending Definitions with a Comma:
  - Trailing commas in object and array definition are legal in ECMAScript 5.
  - Object Example:
    - person = {firstName:"John", lastName:"Doe", age:46,}
  - Array Example:
    - points = [40, 100, 1, 5, 25, 10,];
  - WARNING !!
    Internet Explorer 8 will crash.
    JSON does not allow trailing commas.
  - JSON:
    person = {"firstName":"John", "lastName":"Doe", "age":46}
  - JSON:
    points = [40, 100, 1, 5, 25, 10];
Undefined is Not Null:
  - JavaScript objects, variables, properties, and methods can be undefined.
    In addition, empty JavaScript objects can have the value null.
    This can make it a little bit difficult to test if an object is empty.
    You can test if an object exists by testing if the type is undefined:
  - Incorrect:
    - if (myObj !== null && typeof myObj !== "undefined") 
      Because of this, you must test for not undefined before you can test for not null:
  - Correct:
    - if (typeof myObj !== "undefined" && myObj !== null) 

---------------------------JavaScript Performance--------------------------------------
How to speed up your JavaScript code.
Reduce Activity in Loops:
  - Loops are often used in programming.
    Each statement in a loop, including the for statement, is executed for each iteration of the loop.
    Statements or assignments that can be placed outside the loop will make the loop run faster.
  - Bad:
      for (let i = 0; i < arr.length; i++) {
      }
  - Better Code:
    let l = arr.length;
    for (let i = 0; i < l; i++) {
    }
    - The bad code accesses the length property of an array each time the loop is iterated.
      The better code accesses the length property outside the loop and makes the loop run faster.
Reduce DOM Access:
  - Accessing the HTML DOM is very slow, compared to other JavaScript statements.
  - If you expect to access a DOM element several times, access it once, and use it as a local variable:
    - Example:
      const obj = document.getElementById("demo");
      obj.innerHTML = "Hello";
Reduce DOM Size: 
  - Keep the number of elements in the HTML DOM small.
    This will always improve page loading, and speed up rendering (page display), especially on smaller devices.
  - Every attempt to search the DOM (like getElementsByTagName) will benefit from a smaller DOM.
Avoid Unnecessary Variables:
  - Don't create new variables if you don't plan to save values.
    Often you can replace code like this:
      - let fullName = firstName + " " + lastName;
        document.getElementById("demo").innerHTML = fullName;
      - With this:
        - document.getElementById("demo").innerHTML = firstName + " " + lastName;
Delay JavaScript Loading:
  - Putting your scripts at the bottom of the page body lets the browser load the page first.
  - While a script is downloading, the browser will not start any other downloads.
    In addition all parsing and rendering activity might be blocked.
  - The HTTP specification defines that browsers should not download more than two components in parallel.
  - An alternative is to use defer="true" in the script tag. The defer attribute specifies that the script
    should be executed after the page has finished parsing, but it only works for external scripts.
  - If possible, you can add your script to the page by code, after the page has loaded:
  Example:
  <script>
    window.onload = function() {
    const element = document.createElement("script");
    element.src = "myScript.js";
    document.body.appendChild(element);
    };
  </script>
Avoid Using with:
  - Avoid using the with keyword. It has a negative effect on speed. It also clutters up JavaScript scopes.
  - The with keyword is not allowed in strict mode.

  -------------------------JavaScript Versions----------------------------------------
LINK: https://www.w3schools.com/js/js_versions.asp
JavaScript was invented by Brendan Eich in 1995, and became an ECMA standard in 1997.
ECMAScript is the official name of the language.
ECMAScript versions have been abbreviated to ES1, ES2, ES3, ES5, and ES6.
Since 2016, versions are named by year (ECMAScript 2016, 2017, 2018, 2019, 2020).
ECMAScript 2009, also known as ES5, was the first major revision to JavaScript.
Reserved Words as Property Names:
  - ES5 allows reserved words as property names:
    Object Example: 
      - var obj = {name: "John", new: "yes"}

Array methods:
  - isArray() method checks whether an object is an array.
  - forEach() method calls a function once for each array element.
    Performs the specified action for each element in an array.
  - Array map() Calls a defined callback function on each element of an array, 
    and returns an array that contains the results.
  - Array filter() Returns the elements of an array that meet the condition specified in a callback function.
  - Array reduce() Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result,
     and is provided as an argument in the next call to the callback function.
  - Array reduceRight() Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result,
     and is provided as an argument in the next call to the callback function.
  - Array every() Determines whether all the members of an array satisfy the specified test.
  - Array some() Determines whether the specified callback function returns true for any element of an array.
  - Array indexOf() Returns the index of the first occurrence of a value in an array, or -1 if it is not present.

JSON:
  - JSON.parse() is used to convert the text into a JavaScript object:
  - Date toJSON() toJSON() converts a Date object into a string, formatted as a JSON date.
    JSON dates have the same format as the ISO-8601 standard: YYYY-MM-DDTHH:mm:ss.sssZ:
  - WARNING !!!
    JSON does not allow trailing commas.
     JSON Objects:
      - // Allowed:
        var person = '{"firstName":"John", "lastName":"Doe", "age":46}'
        JSON.parse(person) 

        // Not allowed:
        var person = '{"firstName":"John", "lastName":"Doe", "age":46,}'
        JSON.parse(person)
    - JSON Arrays:
      - // Allowed:
        points = [40, 100, 1, 5, 25, 10]

        // Not allowed:
        points = [40, 100, 1, 5, 25, 10,]
Object.defineProperty():
  - Object.defineProperty() is a new Object method in ES5.
    It lets you define an object property and/or change a property's value and/or metadata.
E5 Object Methods:
  - // Create object with an existing object as prototype
    Object.create(parent, donor)

    // Adding or changing an object property
    Object.defineProperty(object, property, descriptor)

    // Adding or changing object properties
    Object.defineProperties(object, descriptors)

    // Accessing Properties
    Object.getOwnPropertyDescriptor(object, property)

    // Returns all properties as an array
    Object.getOwnPropertyNames(object)

    // Accessing the prototype
    Object.getPrototypeOf(object)

    // Returns enumerable properties as an array
    Object.keys(object)
Protecting Objects:
  - // Prevents adding properties to an object
    Object.preventExtensions(object)

   // Returns true if properties can be added to an object
   Object.isExtensible(object)

   // Prevents changes of object properties (not values)
    Object.seal(object)

   // Returns true if object is sealed
   Object.isSealed(object)

   // Prevents any changes to an object
   Object.freeze(object)

   // Returns true if object is frozen
   Object.isFrozen(object)
Trailing Commas
ES5 allows trailing commas in object and array definitions:
  - Object Example
    person = {
      firstName: "John",
      lastName: " Doe",
      age: 46,
    }

---------------------------Javascript ES6-------------------------------------------
ECMAScript 2015 was the second major revision to JavaScript.
ECMAScript 2015 is also known as ES6 and ECMAScript 6.
This chapter describes the most important features of ES6.
JavaScript let:
  - The let keyword allows you to declare a variable with block scope.
JavaScript const:
  - The const keyword allows you to declare a constant (a JavaScript variable with a constant value).
    Constants are similar to let variables, except that the value cannot be changed.
Arrow Functions:
  - Arrow functions allows a short syntax for writing function expressions.
    You don't need the function keyword, the return keyword, and the curly brackets.
  - Arrow functions do not have their own this. They are not well suited for defining object methods.
    Arrow functions are not hoisted. They must be defined before they are used.
    Using const is safer than using var, because a function expression is always a constant value.
    You can only omit the return keyword and the curly brackets if the function is a single statement. 
    Because of this, it might be a good habit to always keep them:
  - The Spread (...) Operator:
    - The ... operator expands an iterable (like an array) into more elements:
    - The ... operator can be used to expand an iterable into more arguments for function calls:
      - Example:
        const numbers = [23,55,21,87,56];
        let maxValue = Math.max(...numbers);
The For/Of Loop:
  - The JavaScript for/of statement loops through the values of an iterable objects.
    for/of lets you loop over data structures that are iterable such as Arrays, Strings, Maps, NodeLists, and more.
    The for/of loop has the following syntax:
    for (variable of iterable) {
      // code block to be executed
    }
  - variable - For every iteration the value of the next property is assigned to the variable. Variable can be declared with const, let, or var.
    iterable - An object that has iterable properties.
JavaScript Maps:
  - Being able to use an Object as a key is an important Map feature.
JavaScript Classes:
  - JavaScript Classes are templates for JavaScript Objects.
    Use the keyword class to create a class.
    Always add a method named constructor():
    Syntax
    class ClassName {
       constructor() { ... }
    }
JavaScript Promises:
  - A Promise is a JavaScript object that links "Producing Code" and "Consuming Code".
    "Producing Code" can take some time and "Consuming Code" must wait for the result.
  - Promise Syntax:
    - const myPromise = new Promise(function(myResolve, myReject) {
      // "Producing Code" (May take some time)

      myResolve(); // when successful
      myReject();  // when error
      });

      // "Consuming Code" (Must wait for a fulfilled Promise).
      myPromise.then(
        function(value) { /* code if successful */ },
        function(error) { /* code if some error */ }
      );
The Symbol Type:
  - A JavaScript Symbol is a primitive datatype just like Number, String, or Boolean.
    It represents a unique "hidden" identifier that no other code can accidentally access.
    For instance, if different coders want to add a person.id property to a person 
    object belonging to a third-party code, they could mix each others values.
  - Note:
    Symbols are always unique.
    If you create two symbols with the same description they will have different values:
    Symbol("id") == Symbol("id"); // false
Default Parameter Values:
  - ES6 allows function parameters to have default values.
Function Rest Parameter:
  - The rest parameter (...) allows a function to treat an indefinite number of arguments as an array:
String.includes():
  - The includes() method returns true if a string contains a specified value, otherwise false:
String.startsWith():
  - The startsWith() method returns true if a string begins with a specified value, otherwise false:
String.endsWith():
  - The endsWith() method returns true if a string ends with a specified value, otherwise false:
Array.from():
  - The Array.from() method returns an Array object from any object with a length property or any iterable object.
    - Array.from("ABCDEFG")   // Returns [A,B,C,D,E,F,G] 
Safe Integer:
  - Safe integers are all integers from -(253 - 1) to +(253 - 1).
    This is safe: 9007199254740991. This is not safe: 9007199254740992.
The isFinite() Method:
  -  global isFinite() method returns false if the argument is Infinity or NaN.
    Otherwise it returns true:

--------------------------ECMAScript 2016----------------------------------------------
JavaScript Version Numbers:
  - Old JS versions are named by numbers: ES5 (2009) and ES6 (2015).
  - From 2016, versions are named by year: ECMAScript 2016, 2017, 2018, 2019, ...
Exponentiation Operator:
  - The exponentiation operator (**) raises the first operand to the power of the second operand.
    - Example:
      let x = 5;
      let z = x ** 2;
    - x ** y produces the same result as Math.pow(x, y):
Exponentiation Assignment:
  - The exponentiation assignment operator (**=) raises the value of a variable to the power of the right operand.

-------------------------ECMAScript 2017-----------------------------------------------
JavaScript String Padding:
  - ECMAScript 2017 added two string methods to JavaScript: padStart() and padEnd()
    to support padding at the beginning and at the end of a string.
  - JavaScript Object Entries:
    - Object.entries() returns an array of the key/value pairs in an object:
    - Object.entries() makes it simple to use objects in loops:
    - Object.entries() also makes it simple to convert objects to maps:
      - const fruits = {Bananas:300, Oranges:200, Apples:500};
        const myMap = new Map(Object.entries(fruits));
JavaScript Object Values:
  - Object.values() are similar to Object.entries(), but returns a single dimension array of the object values:
JavaScript Async Functions:
async function myDisplay() {
  let myPromise = new Promise(function(myResolve, myReject) {
    setTimeout(function() { myResolve("I love You !!"); }, 3000);
  });
  document.getElementById("demo").innerHTML = await myPromise;
}

myDisplay();

--------------------------ECMAScript 2018---------------------------------------------
JavaScript Asynchronous Iteration:
  - ECMAScript 2018 added asynchronous iterators and iterables.
    With asynchronous iterables, we can use the await keyword in for/of loops.
JavaScript Promise.finally:
  - ECMAScript 2018 finalizes the full implementation of the Promise object with Promise.finally:
    - Example:
      let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
      x; // 1
      y; // 2
      z; // { a: 3, b: 4 }
JavaScript Threads:
  - In JavaScript you use the Web Workers API to create threads.
  - Worker threads are used to execute code in the background so that the main program can continue execution.
  - Worker threads run simultaneously with the main program. Simultaneous execution of different parts of a program can be time-saving.
JavaScript Shared Memory:
  - Shared memory is a feature that allows threads (different parts of a program) to access and update the same data in the same memory.
    Instead of passing data between threads, you can pass a SharedArrayBuffer object that points to the memory where data is saved.
SharedArrayBuffer:
  - A SharedArrayBuffer object represents a fixed-length raw binary data buffer similar to the ArrayBuffer object.

------------------------ECMAScript 2019----------------------------------------------
Warning
These features are relatively new.
Older browsers may need an alternative code (Polyfill)
JavaScript String trimStart():
  - ES2019 added the String method trimStart() to JavaScript.
    The trimStart() method works like trim(), but removes whitespace only from the start of a string.
JavaScript String trimEnd(): 
  - ES2019 added the String method trimEnd() to JavaScript.
    The trimEnd() method works like trim(), but removes whitespace only from the end of a string.
JavaScript Object fromEntries():
  - ES2019 added the Object method fromEntries() to JavaScript.
    The fromEntries() method creates an object from iterable key / value pairs.
Optional catch Binding:
  - From ES2019 you can omit the catch parameter if you don't need it:
    - Example:
      Before 2019:
      
      try {
        // code
      } catch (err) {
        // code
      }
      After 2019:
      try {
        // code
      } catch {
        // code
      }
JavaScript Array flat():
  - ES2019 added the Array flat() method to JavaScript.
    The flat() method creates a new array by flattening a nested array.
JavaScript Array flatMap():
  - ES2019 added the Array flatMap() method to JavaScript.
    The flatMap() method first maps all elements of an array and then creates a new array by flattening the array.
Stable Array sort():
  - ES2019 revised the Array sort() method.
    Before 2019, the specification allowed unstable sorting algorithms such as QuickSort.
    After ES2019, browsers must use a stable sorting algorithm:
    When sorting elements on a value, the elements must keep their relative position to other elements with the same value.
Revised Function toString():
  - ES2019 revised the Function toString() method.
    The toString() method returns a string representing the source code of a function.
    From 2019, toString() must return the source code of the function including comments, spaces, and syntax details.
    Before 2019, different browsers returned different variants of the function (like without comments and spaces). 
    From 2019 the function should be returned exactly as it is written.

-------------------------------ECMAScript 2020---------------------------------------------------------------------
JavaScript BigInt:
  - JavaScript BigInt variables are used to store big integer values that are too big to be represented by a a normal JavaScript Number.
    JavaScript integers are only accurate up to about 15 digits.
    Integer Example:
      - let x = 999999999999999;
        let y = 9999999999999999; // too big
    BigInt Example:
      - let x = 9999999999999999;
        let y = 9999999999999999n;
  - To create a BigInt, append n to the end of an integer or call BigInt():
    - let x = 1234567890123456789012345n;
      let y = BigInt(1234567890123456789012345)
JavaScript String matchAll():
  - Before ES2020 there was no string method that could be used to search for all occurrences of a string in a string.
    - const iterator = text.matchAll("Cats");
  - If the parameter is a regular expression, the global flag (g) must be set set, otherwise a TypeError is thrown.
    - const iterator = text.matchAll(/Cats/g);
The Nullish Coalescing Operator (??):
  - The ?? operator returns the first argument if it is not nullish (null or undefined).
    Otherwise it returns the second.
The Optional Chaining Operator (?.):
  - The Optional Chaining Operator returns undefined if an object is undefined or null (instead of throwing an error).
The &&= Operator:
  - The Logical AND Assignment Operator is used between two values.
    If the first value is true, the second value is assigned.
The ||= Operator:
  - The Logical OR Assignment Operator is used between two values.
    If the first value is false, the second value is assigned.
The ??= Operator:
  - The Nullish Coalescing Assignment Operator is used between two values.
    If the first value is undefined or null, the second value is assigned

-----------------------------------ECMAScript 2021----------------------------------------------------
JavaScript String ReplaceAll():
  - The replaceAll() method allows you to specify a regular expression instead of a string to be replaced.
    If the parameter is a regular expression, the global flag (g) must be set, otherwise a TypeError is thrown.
JavaScript Numeric Separator (_):
  - ES2021 intoduced the numeric separator (_) to make numbers more readable:
    - const num = 1_000_000_000;
  - The numeric separator is only for visual use.
  - The numeric separator can be placed anywhere in a number:
  - NOTE:
    - The numeric separator is not allowed at the beginning or at the end of a number.
      In JavaScript only variables can start with _.
JavaScript Array at():
  - ES2022 intoduced the array method at():
  - The at() method returns an indexed element from an array.
  - The at() method returns the same as [].
  - The at() method is supported in all modern browsers since March 2022:
JavaScript String at():
  - ES2022 intoduced the string method at():
  - The at() method returns an indexed element from an string.
  - The at() method returns the same as [].
  - The at() method is supported in all modern browsers since March 2022:

------------------------------JavaScript History-------------------------------------------------
JavaScript / ECMAScript:
  - JavaScript was invented by Brendan Eich in 1995.
    It was developed for Netscape 2, and became the ECMA-262 standard in 1997.
  - After Netscape handed JavaScript over to ECMA, the Mozilla foundation continued to develop 
    JavaScript for the Firefox browser. Mozilla's latest version was 1.8.5. (Identical to ES5).
    Internet Explorer (IE4) was the first browser to support ECMA-262 Edition 1 (ES1).

----------------------------JavaScript Objects------------------------------------------------
In JavaScript, objects are king. If you understand objects, you understand JavaScript.
In JavaScript, almost "everything" is an object:
  - Booleans can be objects (if defined with the new keyword)
  - Numbers can be objects (if defined with the new keyword)
  - Strings can be objects (if defined with the new keyword)
  - Dates are always objects
  - Maths are always objects
  - Regular expressions are always objects
  - Arrays are always objects
  - Functions are always objects
  - Objects are always objects
  - All JavaScript values, except primitives, are objects.
JavaScript Primitives:
  - A primitive value is a value that has no properties or methods.
    3.14 is a primitive value 
    A primitive data type is data that has a primitive value.
    JavaScript defines 7 types of primitive data types:
      - Examples:
        string
        number
        boolean
        null
        undefined
        symbol
        bigint
Immutable:
  - Primitive values are immutable (they are hardcoded and cannot be changed).
    if x = 3.14, you can change the value of x, but you cannot change the value of 3.14.
Objects are Variables:
  - JavaScript variables can contain single values:
    Example:
      let person = "John Doe";
  - JavaScript variables can also contain many values.
    Objects are variables too. But objects can contain many values.
    Object values are written as name : value pairs (name and value separated by a colon).
  - A JavaScript object is a collection of named values
  - It is a common practice to declare objects with the const keyword.
Object Properties:
  - The named values, in JavaScript objects, are called properties.
  - Objects written as name value pairs are similar to:
      - Associative arrays in PHP
      - Dictionaries in Python
      - Hash tables in C
      - Hash maps in Java
      - Hashes in Ruby and Perl
Object Methods:
  - Methods are actions that can be performed on objects.
    Object properties can be both primitive values, other objects, and functions.
    An object method is an object property containing a function definition.
  - JavaScript objects are containers for named values, called properties and methods.
Creating a JavaScript Object:
  - There are different ways to create new objects:
      - Create a single object, using an object literal.
      - Create a single object, with the keyword new.
      - Define an object constructor, and then create objects of the constructed type.
      - Create an object using Object.create().
Using an Object Literal:
  - This is the easiest way to create a JavaScript Object.
  - Using an object literal, you both define and create an object in one statement.
  - An object literal is a list of name:value pairs (like age:50) inside curly braces {}.
Using the JavaScript Keyword new:
  - The examples above do exactly the same.
    But there is no need to use new Object().
    For readability, simplicity and execution speed, use the object literal method.
JavaScript Objects are Mutable:
  - Objects are mutable: They are addressed by reference, not by value.
    If person is an object, the following statement will not create a copy of person:
    const x = person;  // Will not create a copy of person.
    The object x is not a copy of person. It is person. Both x and person are the same object.
    Any changes to x will also change person, because x and person are the same object.
      - Example:
      const person = {
      firstName:"John",
      lastName:"Doe",
      age:50, eyeColor:"blue"
     }

      const x = person;
      x.age = 10;      // Will change both x.age and person.age

---------------------------------JavaScript Object Properties--------------------------------
Properties are the values associated with a JavaScript object.
A JavaScript object is a collection of unordered properties.
Properties can usually be changed, added, and deleted, but some are read only.
Accessing JavaScript Properties:
  - The expression must evaluate to a property name.
  - objectName.property      // person.age
    or
    objectName["property"]   // person["age"]
    or
    objectName[expression]   // x = "age"; person[x]
Adding New Properties:
  - You can add new properties to an existing object by simply giving it a value.
  - Assume that the person object already exists - you can then give it new properties:
  - Example:
    - person.nationality = "English";
Deleting Properties:
  - The delete keyword deletes a property from an object:
  - The delete keyword deletes both the value of the property and the property itself.
  - After deletion, the property cannot be used before it is added back again.
  - The delete operator is designed to be used on object properties. It has no effect on variables or functions.
  - The delete operator should not be used on predefined JavaScript object properties. It can crash your application.
Nested Objects:
  - Values in an object can be another object:
  - You can access nested objects using the dot notation or the bracket notation:
    - Example:
      myObj.cars.car2;
Nested Arrays and Objects:
  - Values in objects can be arrays, and values in arrays can be objects:
  - To access arrays inside arrays, use a for-in loop for each array:
Property Attributes:
  - All properties have a name. In addition they also have a value.
    The value is one of the property's attributes.
    Other attributes are: enumerable, configurable, and writable.
    These attributes define how the property can be accessed (is it readable?, is it writable?)
    In JavaScript, all attributes can be read, but only the value attribute can be changed (and only if the property is writable).
Prototype Properties:
  - JavaScript objects inherit the properties of their prototype.
  - The delete keyword does not delete inherited properties, but if you delete a prototype property, 
    it will affect all objects inherited from the prototype.
How to Display JavaScript Objects?
  - Displaying a JavaScript object will output [object Object].
  - You must use person[x] in the loop. person.x will not work (Because x is a variable).
  - Any JavaScript object can be converted to an array using Object.values():
Stringify Functions:
  - JSON.stringify will not stringify functions:
JavaScript Object Accessors:
  - JavaScript Accessors (Getters and Setters):
    - Getters and setters allow you to define Object Accessors (Computed Properties).
JavaScript Function or Getter?:
  - What is the differences between these two examples?
  - access fullName as a function: person.fullName().
  - access fullName as a property: person.fullName.
  - JavaScript can secure better data quality when using getters and setters.
Why Using Getters and Setters?:
  - It gives simpler syntax
  - It allows equal syntax for properties and methods
  - It can secure better data quality
  - It is useful for doing things behind-the-scenes
JavaScript Object Constructors:
  - It is considered good practice to name constructor functions with an upper-case first letter.
  - In a constructor function this does not have a value. It is a substitute for the new object.
    The value of this will become the new object when a new object is created.
Adding a Property to a Constructor:
  - You cannot add a new property to an object constructor the same way you add a new property to an existing object:
  - To add a new property to a constructor, you must add it to the constructor function:
Built-in JavaScript Constructors:
  - JavaScript has built-in constructors for native objects:
  - The Math() object is not in the list. Math is a global object. The new keyword cannot be used on Math.
JavaScript Object Prototypes:
  - All JavaScript objects inherit properties and methods from a prototype.
  - NOTE: We also learned that you can not add a new property to an existing object constructor:
  - To add a new property to a constructor, you must add it to the constructor function:
Prototype Inheritance:
  - Date objects inherit from Date.prototype
  - Array objects inherit from Array.prototype
  - Person objects inherit from Person.prototype
    The Object.prototype is on the top of the prototype inheritance chain:
    Date objects, Array objects, and Person objects inherit from Object.prototype.
Adding Properties and Methods to Objects:
  - Sometimes you want to add new properties (or methods) to all existing objects of a given type.
  - Sometimes you want to add new properties (or methods) to an object constructor.
Using the prototype Property:
  - The JavaScript prototype property allows you to add new properties to object constructors:
  - Example:
    function Person(first, last, age, eyecolor) {
      this.firstName = first;
      this.lastName = last;
      this.age = age;
      this.eyeColor = eyecolor;
    }
    Person.prototype.nationality = "English";
JavaScript Iterables:
  - Iterable objects are objects that can be iterated over with for..of.
  - Technically, iterables must implement the Symbol.iterator method.
  - The next() method must return an object with two properties:
    - value (the next value)
    - done (true or false)
JavaScript Sets:
  - A JavaScript Set is a collection of unique values.
  - Each value can only occur once in a Set.
  - A Set can hold any value of any data type.
  - Set Methods:
    - Method	Description
    - new Set()	Creates a new Set
    - add()	Adds a new element to the Set
    - delete()	Removes an element from a Set
    - has()	Returns true if a value exists
    - clear()	Removes all elements from a Set
    - forEach()	Invokes a callback for each element
    - values()	Returns an Iterator with all the values in a Set
    - keys()	Same as values()
    - entries()	Returns an Iterator with the [value,value] pairs from a Set
    Property	Description
    - size	Returns the number elements in a Set
  - The forEach() method invokes a function for each Set element:
  - The values() method returns an Iterator object containing all the values in a Set:
  - A Set has no keys. keys() returns the same as values().This makes Sets compatible with Maps.
  - A Set has no keys.entries() returns [value,value] pairs instead of [key,value] pairs.
    This makes Sets compatible with Maps:
JavaScript Maps:
  - A Map holds key-value pairs where the keys can be any datatype.
  - A Map remembers the original insertion order of the keys.
  - A Map has a property that represents the size of the map.
  - Map Methods:
    - new Map()	Creates a new Map object
    - set()	Sets the value for a key in a Map 
    - get()	Gets the value for a key in a Map
    - clear()	Removes all the elements from a Map
    - delete()	Removes a Map element specified by a key
    - has()	Returns true if a key exists in a Map
    - forEach()	Invokes a callback for each key/value pair in a Map
    - entries()	Returns an iterator object with the [key, value] pairs in a Map
    - keys()	Returns an iterator object with the keys in a Map
    - values()	Returns an iterator object of the values in a Map
    - size	Returns the number of Map elements
  - You can add elements to a Map with the set() method:
    - The set() method can also be used to change existing Map values:
  - The get() method gets the value of a key in a Map:
  - The forEach() method invokes a callback for each key/value pair in a Map:
  - The entries() method returns an iterator object with the [key,values] in a Map:
  - The keys() method returns an iterator object with the keys in a Map:
  - The values() method returns an iterator object with the values in a Map:
JavaScript Objects vs Maps:
  - Not directly iterable	Directly iterable
  - Do not have a size property	Have a size property
  - Keys must be Strings (or Symbols)	Keys can be any datatype
  - Keys are not well ordered	Keys are ordered by insertion
  - Have default keys	Do not have default keys
Being able to use objects as keys is an important Map feature.

---------------------------------JavaScript Function-----------------------------------
JavaScript Function Definitions:
  - JavaScript functions are defined with the function keyword.
  - You can use a function declaration or a function expression.
  - NOTE: Semicolons are used to separate executable JavaScript statements.
    Since a function declaration is not an executable statement,
    it is not common to end it with a semicolon.
Function Expressions:
  - A JavaScript function can also be defined using an expression.
  - A function expression can be stored in a variable:
  - After a function expression has been stored in a variable,
    the variable can be used as a function:
  - The function above is actually an anonymous function (a function without a name).
    Functions stored in variables do not need function names.
    They are always invoked (called) using the variable name.
  - The function above ends with a semicolon because it is a part of an executable statement.
The Function() Constructor:
  - Functions can also be defined with a built-in JavaScript function constructor called Function().
  - Most of the time, you can avoid using the new keyword in JavaScript.
Self-Invoking Functions:
  - Function expressions can be made "self-invoking".
  - A self-invoking expression is invoked (started) automatically, without being called.
  - Function expressions will execute automatically if the expression is followed by ().
  - You cannot self-invoke a function declaration.
  - You have to add parentheses around the function to indicate that it is a function expression:
JavaScript functions can be used in expressions:
  - The arguments.length property returns the number of arguments received when the function was invoked:
  - The typeof operator in JavaScript returns "function" for functions.
  - But, JavaScript functions can best be described as objects.
  - JavaScript functions have both properties and methods.
  - The toString() method returns the function as a string:
A function defined as the property of an object, is called a method to the object.
A function designed to create new objects, is called an object constructor.
Arrow Functions:
  - Arrow functions allows a short syntax for writing function expressions.
  - You don't need the function keyword, the return keyword, and the curly brackets.
  - Arrow functions do not have their own this. They are not well suited for defining object methods.
  - Arrow functions are not hoisted. They must be defined before they are used.
  - Using const is safer than using var, because a function expression is always constant value.
  - You can only omit the return keyword and the curly brackets if the function is a single statement. Because of this, it might be a good habit to always keep them:
JavaScript Function Parameters:
  - JavaScript function definitions do not specify data types for parameters.
  - JavaScript functions do not perform type checking on the passed arguments.
  - JavaScript functions do not check the number of arguments received.
JavaScript Function Invocation:
  - The code inside a function is not executed when the function is defined.
  - The code inside a function is executed when the function is invoked.
  - It is common to use the term "call a function" instead of "invoke a function".
  - It is also common to say "call upon a function", "start a function", or "execute a function".
NOTE:
  - This is a common way to invoke a JavaScript function, but not a very good practice.
    Global variables, methods, or functions can easily create name conflicts and bugs in the global object.
The Global Object:
  - When a function is called without an owner object, the value of this becomes the global object.
    In a web browser the global object is the browser window.
Invoking a Function with a Function Constructor:
  - If a function invocation is preceded with the new keyword, it is a constructor invocation.
Note:
  -The this keyword in the constructor does not have a value.
  - The value of this will be the new object created when the function is invoked.
JavaScript Function call():
  - With the call() method, you can write a method that can be used on different objects.
Method Reuse:
  - apply() method, you can write a method that can be used on different objects.
  - Math. max() method returns the number with the highest value.
JavaScript Closures:
  - JavaScript variables can belong to the local or global scope.
  - Global variables can be made local (private) with closures.
NOTE: 
  - Variables created without a declaration keyword (var, let, or const) are always global, 
    even if they are created inside a function.
Variable Lifetime:
  - Global variables live until the page is discarded, like when you navigate to another page or close the window.
  - Local variables have short lives. They are created when the function is invoked, and deleted when the function is finished.
JavaScript Nested Functions:
  - All functions have access to the global scope.  
  - In fact, in JavaScript, all functions have access to the scope "above" them.
  - JavaScript supports nested functions. Nested functions have access to the scope "above" them.
JavaScript Closures:
  - The self-invoking function only runs once. It sets the counter to zero (0), and returns a function expression.
  - This way add becomes a function. The "wonderful" part is that it can access the counter in the parent scope.
  - This is called a JavaScript closure. It makes it possible for a function to have "private" variables.
  - The counter is protected by the scope of the anonymous function, and can only be changed using the add function.
-----------------------------JavaScript Classes------------------------------------------
Note:  A JavaScript class is not an object.It is a template for JavaScript objects.
The Constructor Method:
  - It has to have the exact name "constructor"
  - It is executed automatically when a new object is created
  - It is used to initialize object properties
"use strict":
  - The syntax in classes must be written in "strict mode".
  - You will get an error if you do not follow the "strict mode" rules.
Class Inheritance:
  - To create a class inheritance, use the extends keyword.
  - A class created with a class inheritance inherits all the methods from another class:

 ----------------------------JavaScript Callbacks--------------------------------------
"I will call back later!"
A callback is a function passed as an argument to another function
This technique allows a function to call another function
A callback function can run after another function has finished
JavaScript Callbacks:
  - A callback is a function passed as an argument to another function.
  - NOTE: When you pass a function as an argument, remember not to use parenthesis.
When to Use a Callback?:
  - Where callbacks really shine are in asynchronous functions,
     where one function has to wait for another function (like waiting for a file to load).
Asynchronous JavaScript:
"I will finish later!"
Functions running in parallel with other functions are called asynchronous
A good example is JavaScript setTimeout()
In the real world, callbacks are most often used with asynchronous functions.

  - Instead of passing the name of a function as an argument to another function, 
    you can always pass a whole function instead
Callback Alternatives: 
  - With asynchronous programming, JavaScript programs can start long-running tasks,
   and continue running other tasks in paralell.
   But, asynchronus programmes are difficult to write and difficult to debug.
   Because of this, most modern asynchronous JavaScript methods don't use callbacks. Instead, in JavaScript,
   asynchronous programming is solved using Promises instead.
JavaScript Promises:
  "I Promise a Result!"
"Producing code" is code that can take some time
"Consuming code" is code that must wait for the result
A Promise is a JavaScript object tcode and consuming code
JavaScript Promise Object:
  - A JavaScript Promise object contains both the producing code and calls to the consuming code:
  - A JavaScript Promise object can be:
    - Pending
    - Fulfilled
    - Rejected
  - The Promise object supports two properties: state and result.
  - While a Promise object is "pending" (working), the result is undefined.
  - When a Promise object is "fulfilled", the result is a value.
  - When a Promise object is "rejected", the result is an error object.
Note:
  - You cannot access the Promise properties state and result.
  - You must use a Promise method to handle promises.
JavaScript Async:
  - "async and await make promises easier to write"
  - async makes a function return a Promise
  - await makes a function wait for a Promise
Async Syntax:
  - The keyword async before a function makes the function return a promise:
Await Syntax:
  - The await keyword can only be used inside an async function.
  - The await keyword makes the function pause the execution and wait for a resolved promise before it continues:
Note: 
  - The two arguments (resolve and reject) are pre-defined by JavaScript.
  - We will not create them, but call one of them when the executor function is ready.
  - Very often we will not need a reject function.

-------------------------------JavaScript HTML DOM-------------------------------------------
The HTML DOM (Document Object Model):
  - With the HTML DOM, JavaScript can access and change all the elements of an HTML document.
  When a web page is loaded, the browser creates a Document Object Model of the page.
  - The HTML DOM model is constructed as a tree of Objects:
  - With the object model, JavaScript gets all the power it needs to create dynamic HTML:
    - JavaScript can change all the HTML elements in the page
    - JavaScript can change all the HTML attributes in the page
    - JavaScript can change all the CSS styles in the page
    - JavaScript can remove existing HTML elements and attributes
    - JavaScript can add new HTML elements and attributes
    - JavaScript can react to all existing HTML events in the page
    - JavaScript can create new HTML events in the page
What is the DOM?:
The HTML DOM is a standard object model and programming interface for HTML. It defines:
  - The HTML elements as objects
  - The properties of all HTML elements
  - The methods to access all HTML elements
  - The events for all HTML elements
In other words: The HTML DOM is a standard for how to get, change, add, or delete HTML elements.
JavaScript - HTML DOM Methods:
HTML DOM methods are actions you can perform (on HTML Elements).
HTML DOM properties are values (of HTML Elements) that you can set or change.
  - The DOM Programming Interface:
    The HTML DOM can be accessed with JavaScript (and with other programming languages).
    In the DOM, all HTML elements are defined as objects.
    The programming interface is the properties and methods of each object.
    A property is a value that you can get or set (like changing the content of an HTML element).
    A method is an action you can do (like add or deleting an HTML element).
    ex(getElementById is a method, while innerHTML is a property);
  - The getElementById Method:
  The most common way to access an HTML element is to use the id of the element.
  - The innerHTML Property:
   The easiest way to get the content of an element is by using the innerHTML property.
   The innerHTML property is useful for getting or replacing the content of HTML elements.
   The innerHTML property can be used to get or change any HTML element, including <html> and <body>.
JavaScript HTML DOM Document:
  - The HTML DOM Document Object:
  The document object represents your web page.
  If you want to access any element in an HTML page, you always start with accessing the document object.
  - Finding HTML Elements:
    - document.getElementById(id)	Find an element by element id
    - document.getElementsByTagName(name)	Find elements by tag name
    - document.getElementsByClassName(name)	Find elements by class name
  - Changing HTML Elements: 
    - element.innerHTML =  new html content	Change the inner HTML of an element
    - element.attribute = new value	Change the attribute value of an HTML element
    - element.style.property = new style	Change the style of an HTML element
    - element.setAttribute(attribute, value)	Change the attribute value of an HTML element
  - Adding and Deleting Elements:
    - document.createElement(element)	Create an HTML element
    - document.removeChild(element)	Remove an HTML element
    - document.appendChild(element)	Add an HTML element
    - document.replaceChild(new, old)	Replace an HTML element
    - document.write(text)	Write into the HTML output stream
  - Adding Events Handlers:
    - document.getElementById(id).onclick = function(){code}	Adding event handler code to an onclick event
  - Finding HTML Objects:
    - The first HTML DOM Level 1 (1998), defined 11 HTML objects, object collections, and properties. These are still valid in HTML5.
    Later, in HTML DOM Level 3, more objects, collections, and properties were added.
 
Property	Description	DOM
document.anchors	Returns all <a> elements that have a name attribute	1
document.applets	Deprecated	1
document.baseURI	Returns the absolute base URI of the document	3
document.body	Returns the <body> element	1
document.cookie	Returns the document's cookie	1
document.doctype	Returns the document's doctype	3
document.documentElement	Returns the <html> element	3
document.documentMode	Returns the mode used by the browser	3
document.documentURI	Returns the URI of the document	3
document.domain	Returns the domain name of the document server	1
document.domConfig	Obsolete.	3
document.embeds	Returns all <embed> elements	3
document.forms	Returns all <form> elements	1
document.head	Returns the <head> element	3
document.images	Returns all <img> elements	1
document.implementation	Returns the DOM implementation	3
document.inputEncoding	Returns the document's encoding (character set)	3
document.lastModified	Returns the date and time the document was updated	3
document.links	Returns all <area> and <a> elements that have a href attribute	1
document.readyState	Returns the (loading) status of the document	3
document.referrer	Returns the URI of the referrer (the linking document)	1
document.scripts	Returns all <script> elements	3
document.strictErrorChecking	Returns if error checking is enforced	3
document.title	Returns the <title> element	1
document.URL	Returns the complete URL of the document	1

Finding HTML Element by Id:
  - The easiest way to find an HTML element in the DOM, is by using the element id.
  - If the element is found, the method will return the element as an object (in element).
  - If the element is not found, element will contain null.

Finding HTML Elements by CSS Selectors: 
  - If you want to find all HTML elements that match a specified CSS selector (id, class names, types, attributes, 
    values of attributes, etc), use the querySelectorAll() method.
Changing HTML Content:
  - The easiest way to modify the content of an HTML element is by using the innerHTML property.
Changing the Value of an Attribute:
  - use this syntax:
    - document.getElementById(id).attribute = new value
document.write():
  - document.write() can be used to write directly to the HTML output stream.
  - NOTE: - Never use document.write() after the document is loaded. It will overwrite the document.
Data Validation:
  - Data validation is the process of ensuring that user input is clean, correct, and useful.
    Typical validation tasks are:
  has the user filled in all required fields?
  has the user entered a valid date?
  has the user entered text in a numeric field?
  - Most often, the purpose of data validation is to ensure correct user input.
  -Validation can be defined by many different methods, and deployed in many different ways.
  - Validation can be defined by many different methods, and deployed in many different ways.

  - Client side validation is performed by a web browser, before input is sent to a web server.
HTML Constraint Validation:
  - HTML5 introduced a new HTML validation concept called constraint validation.
  - HTML constraint validation is based on:
    - Constraint validation HTML Input Attributes
    - Constraint validation CSS Pseudo Selectors
    - Constraint validation DOM Properties and Methods
Constraint Validation HTML Input Attributes:
  - Attribute     	    Description
    disabled        	  Specifies that the input element should be disabled
    max	                Specifies the maximum value of an input element
    min	                Specifies the minimum value of an input element
    pattern            	Specifies the value pattern of an input element
    required           	Specifies that the input field requires an element
    type              	Specifies the type of an input element
Constraint Validation CSS Pseudo Selectors:
  - Selector	          Description
    :disabled	          Selects input elements with the "disabled" attribute specified
    :invalid	          Selects input elements with invalid values
    :optional	          Selects input elements with no "required" attribute specified
    :required	          Selects input elements with the "required" attribute specified
    :valid	            Selects input elements with valid values
JavaScript HTML DOM - Changing CSS:
  - Changing HTML Style:
    - Syntax: document.getElementById(id).style.property = new style

JavaScript HTML DOM Animation:
  - The container element should be created with style = "position: relative".
  - The animation element should be created with style = "position: absolute".
JavaScript HTML DOM Events:
  - Examples of HTML events:
    - When a user clicks the mouse
    - When a web page has loaded
    - When an image has been loaded
    - When the mouse moves over an element
    - When an input field is changed
    - When an HTML form is submitted
    - When a user strokes a key
  - The onload and onunload Events:
    - The onload and onunload events are triggered when the user enters or leaves the page.
    - The onload event can be used to check the visitor's browser type and browser version,
      and load the proper version of the web page based on the information.
  - The onmouseover and onmouseout Events: 
    - The onmouseover and onmouseout events can be used to trigger a 
      function when the user mouses over, or out of, an HTML elemen
  - The onmousedown, onmouseup and onclick Events:
    - The onmousedown, onmouseup, and onclick events are all parts of a mouse-click. First when a mouse-button is clicked, the onmousedown event is triggered, then, when the mouse-button is released, the onmouseup event is triggered,
     finally, when the mouse-click is completed, the onclick event is triggered.