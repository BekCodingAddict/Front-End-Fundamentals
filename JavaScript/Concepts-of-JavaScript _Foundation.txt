-------------------------------JAVASCRIPT--------------------------------------------                       
JS Data Types:
   JavaScript Types are Dynamic. This means the same variable can used to hold diffrent data types:
   let x; //Undefined
   x=5; // Number 
   x="John"; // String

JS Numbers:
  All JavaScript numbers are stored as decimal numbers(floating point);
  All JavaScript numbers are stored in a a 64-bit floating-point format.
  JavaScript BigInt is a new datatype (ES2020) that can be used to store integer values that are too big to be represented by a normal JavaScript Number.


JS Exponential Notation:
  Extra large or extra small numbers can be written with scientific (exponential) notation:
  let y = 123e5;    // 12300000
  let z = 123e-5;   // 0.00123

JS Arrays:
  JavaScript arrays are written with square brackets.
  Array items are separated by commas.
  Array indexes are zero-based, which means the first item is [0], second is [1], and so on.

JS Object:
  JavaScript objects are written with curly braces {}.

JS The typeof Operator:
  You can use the JavaScript typeof operator to find the type of a JavaScript variable.
  The typeof operator returns the type of a variable or an expression.

JS Undefined:
  In JavaScript, a variable without a value, has the value undefined. The type is also undefined.

JS Empty Values:
  An empty value has nothing to do with undefined.
  An empty string has both a legal value and a type.

JS Functions:
  A JavaScript function is a block of code designed to perform a particular task.
  A JavaScript function is defined with the function keyword, followed by a name, followed by parentheses ().
  Function names can contain letters, digits, underscores, and dollar signs (same rules as variables).
  Functions can be used the same way as you use variables, in all types of formulas, assignments, and calculations.

JS Objects:
  Real Life Objects, Properties, and Methods.
  In real life, a car is an object.
  A car has properties like weight and color, and methods like start and stop.
  All cars have the same properties, but the property values differ from car to car.
  All cars have the same methods, but the methods are performed at different times.
  - Comparing two JavaScript objects always returns false.
  
  Objects are variables too. But objects can contain many values.
  It is a common practice to declare objects with the const keyword.
  JavaScript objects are containers for named values called properties.
  Objects can also have methods.
  Methods are actions that can be performed on objects.
  Methods are stored in properties as function definitions.
  Methods:
    A method is a function stored as a property.
  
  WHat is this?:
    In JavaScript, the this keyword refers to an object.
    Which object depends on how this is being invoked (used or called).
    The this keyword refers to different objects depending on how it is used:
      In an object method, this refers to the object.
      Alone, this refers to the global object.
      In a function, this refers to the global object.
      In a function, in strict mode, this is undefined.
      In an event, this refers to the element that received the event.
      Methods like call(), apply(), and bind() can refer this to any object.
  
    this is not a variable. It is a keyword. You cannot change the value of this.
  
  NOTE:
    When a JavaScript variable is declared with the keyword "new", the variable is created as an object.
    Do Not Declare Strings, Numbers, and Booleans as Objects!
    Avoid String, Number, and Boolean objects. They complicate your code and slow down execution speed.
JavaScript Events:
  - HTML Events:
    - An HTML event can be something the browser does, or something a user does.
      Here are some examples of HTML events:
      An HTML web page has finished loading
      An HTML input field was changed
      An HTML button was clicked
      Often, when events happen, you may want to do something.
      JavaScript lets you execute code when events are detected.
      HTML allows event handler attributes, with JavaScript code, to be added to HTML elements.

JavaScript String:
  - JavaScript strings are for storing and manipulating text.
  - A JavaScript string is zero or more characters written inside quotes.
  - You can use quotes inside a string, as long as they don't match the quotes surrounding the string.

JavaScript Breaking Long Code Lines:
  - For best readability, programmers often like to avoid code lines longer than 80 characters.
  - If a JavaScript statement does not fit on one line, 
    the best place to break it is after an operator:
  - You can also break up a code line within a text string with a single backslash:
  - The \ method is not the preferred method. It might not have universal support.
    Some browsers do not allow spaces behind the \ character.
  - A safer way to break up a string, is to use string addition.
  - You cannot break up a code line with a backslash:

JS String Methods:
  - All string methods return a new string.
    They don't modify the original string.
    Formally said:
      Strings are immutable: Strings cannot be changed, only replaced.

  - There are 3 methods for extracting a part of a string:
    - slice(start, end)
      substring(start, end)
      substr(start, length)
      substring() is similar to slice().
      - replace() 
        The replace() method does not change the string it is called on.
        The replace() method returns a new string.
        The replace() method replaces only the first match
        By default, the replace() method is case sensitive.
         Writing Upper-case string will not work:

      replaceAll()- method allows you to specify a regular expression instead of a string to be replaced.
        - Note
          replaceAll() is an ES2021 feature.
          replaceAll() does not work in Internet Explorer.
      toUpperCase()
      toUpperCase()
      concat() joins two or more strings:
        - let text1 = "Hello";
          let text2 = "World";
          let text3 = text1.concat(" ", text2);
      trim()- method removes whitespace from both sides of a string:
      trimStart()- method works like trim(),but removes whitespace only from the start of a string.
      trimEnd()- method works like trim(), but removes whitespace only from the end of a string.
      padStart()- method pads a string from the start.
      split() method:A string can be converted to an array .

  - Extracting String Characters:
    There are 3 methods for extracting string characters:
    charAt(position)
    charCodeAt(position)
    Property access [ ]


The difference is that the second parameter specifies the length of the extracted part.

  - Note
    JavaScript counts positions from zero.
    First position is 0.
    Second position is 1.

  indexOf() method returns the index (position) the first occurrence of a string in a string.
  lastIndexOf() method returns the index of the last occurrence of a specified text in a string.
    - Both indexOf(), and lastIndexOf() return -1 if the text is not found:
      Both methods accept a second parameter as the starting position for the search.
      The lastIndexOf() methods searches backwards (from the end to the beginning), meaning: if the second parameter is 15, the search starts at position 15, 
      and searches to the beginning of the string.
  search() method searches a string for a string (or a regular expression) and returns the position of the match:
    - The two methods, indexOf() and search(), are equal?
      They accept the same arguments (parameters), and return the same value?
      The two methods are NOT equal. These are the differences:
      The search() method cannot take a second start position argument.
      The indexOf() method cannot take powerful search values (regular expressions).
  match() method returns an array containing the results of matching a string against a string (or a regular expression).
  If a regular expression does not include the g modifier (global search), match() will return only the first match in the string.
 
  includes() method returns true if a string contains a specified value.
  startsWith() method returns true if a string begins with a specified value.
  endsWith() method returns true if a string ends with a specified value.

JavaScript Template Literals:
  - Interpolation:
    - Template literals provide an easy way to interpolate variables and expressions into strings.
      The method is called string interpolation.The syntax is:
      ${...}
    - Automatic replacing of expressions with real values is called string interpolation.
    
JavaScript Numbers:
  - JavaScript has only one type of number. Numbers can be written with or without decimals.
  - Extra large or extra small numbers can be written with scientific (exponent) notation:
    - let x = 123e5;    // 12300000
      let y = 123e-5;   // 0.00123
  - JavaScript Numbers are Always 64-bit Floating Point.
  - Integer Precision:
    - Integers (numbers without a period or exponent notation) are accurate up to 15 digits.
    - The maximum number of decimals is 17.
  - Floating Precision:
    - Floating point arithmetic is not always 100% accurate.
  - NaN - Not a Number:
    - NaN is a JavaScript reserved word indicating that a number is not a legal number.
      Trying to do arithmetic with a non-numeric string will result in NaN (Not a Number):
    - NaN is a number: typeof NaN returns number.
  - Infinity (or -Infinity) is the value JavaScript will return if you calculate a number outside the largest possible number.
    - Division by 0 (zero) also generates Infinity.
      - let x =  2 / 0;
        let y = -2 / 0;
    - Infinity is a number: typeof Infinity returns number.
  - Hexadecimal:
    - JavaScript interprets numeric constants as hexadecimal if they are preceded by 0x.
      - let x = 0xFF;
  
  - NOTE:
    - Never write a number with a leading zero (like 07).
      Some JavaScript versions interpret numbers as octal if they are written with a leading zero.
    - By default, JavaScript displays numbers as base 10 decimals.
      But you can use the toString() method to output numbers from base 2 to base 36.
      Hexadecimal is base 16. Decimal is base 10. Octal is base 8. Binary is base 2.
        - let myNumber = 32;
          myNumber.toString(32);
          myNumber.toString(16);
          myNumber.toString(12);
          myNumber.toString(10);
          myNumber.toString(8);
          myNumber.toString(2);
    - Comparing two JavaScript objects always returns false.!

JavaScript BigInt:
  - JavaScript BigInt variables are used to store big integer values that are too big to be represented by a normal JavaScript Number.
  - JavaScript Integer Accuracy:
    - JavaScript integers are only accurate up to 15 digits:
      - Integer Precision
        let x = 999999999999999;
        let y = 9999999999999999;
  - How to Create a BigInt:
    - To create a BigInt, append n to the end of an integer or call BigInt():
      - let y = 9999999999999999n;
      - let y = BigInt(1234567890123456789012345)
    - BigInt is the second numeric data type in JavaScript (after Number).
    - With BigInt the total number of supported data types in JavaScript is 8:
      - 1. String
        2. Number
        3. Bigint
        4. Boolean
        5. Undefined
        6. Null
        7. Symbol
        8. Object

    - Operators that can be used on a JavaScript Number can also be used on a BigInt.
    - NOTE:
      - Arithmetic between a BigInt and a Number is not allowed (type conversion lose information).
      - Unsigned right shift (>>>) can not be done on a BigInt (it does not have a fixed width).
      - A BigInt can not have decimals.
    
    - BigInt can also be written in hexadecimal, octal, or binary notation:
      - let hex = 0x20000000000003n;
        let oct = 0o400000000000000003n
        let bin = 0b100000000000000000000000000000000000000000000000000011n;

    - Precision Curiosity
        - Rounding can compromise program security:
          - MAX_SAFE_INTEGER Example:
            - 9007199254740992 === 9007199254740993; // is true !!!

JavaScript Number Methods:
  - These number methods can be used on all JavaScript numbers:
    - toString()	Returns a number as a string
      toExponential()	Returns a number written in exponential notation
      toFixed()	Returns a number written with a number of decimals:
        - toFixed(2) is perfect for working with money.
      toPrecision()	Returns a number written with a specified length
      ValueOf()	Returns a number as a number

  - Converting Variables to Numbers:
    - There are 3 JavaScript methods that can be used to convert a variable to a number:
      - Number()	Returns a number converted from its argument.
        parseFloat()	Parses its argument and returns a floating point number
        parseInt()	Parses its argument and returns a whole number:
          - Stringdagi 1 numberni aniqlaydi
  
  - Number Object Methods:
    - These object methods belong to the Number object:
      - Number.isInteger()	Returns true if the argument is an integer
        Number.isSafeInteger()	Returns true if the argument is a safe integer
        Number.parseFloat()	Converts a string to a number
        Number.parseInt()	Converts a string to a whole numbe


JavaScript Number Properties:
  - EPSILON	The difference between 1 and the smallest number > 1.
    MAX_VALUE	The largest number possible in JavaScript
    MIN_VALUE	The smallest number possible in JavaScript
    MAX_SAFE_INTEGER	The maximum safe integer (253 - 1)
    MIN_SAFE_INTEGER	The minimum safe integer -(253 - 1)
    POSITIVE_INFINITY	Infinity (returned on overflow):
      - POSITIVE_INFINITY is returned on overflow.
    NEGATIVE_INFINITY	Negative infinity (returned on overflow)
    NaN	A "Not-a-Number" value:
      - NaN is a JavaScript reserved word for a number that is not a legal number.

  - Number Properties Cannot be Used on Variables:
    - Number properties belong to the JavaScript Number Object.
      These properties can only be accessed as Number.MAX_VALUE.
      Using x.MAX_VALUE, where x is a variable or a value, will return undefined:

JavaScript Arrays:
  - It is a common practice to declare arrays with the const keyword.
  - Using the JavaScript Keyword new also create array.
    - There is no need to use new Array().For simplicity,
     readability and execution speed, use the array literal method.
  - Arrays are a special type of objects. The typeof operator in JavaScript returns "object" for arrays.
    - JavaScript variables can be objects. Arrays are special kinds of objects.
      Because of this, you can have variables of different types in the same Array.
      You can have objects in an Array. You can have functions in an Array. You can have arrays in an Array.
  - The easiest way to add a new element to an array is using the push() method:
  - New element can also be added to an array using the length property.
  - NOTE: 
    - Adding elements with high indexes can create undefined "holes" in an array.
  - Associative Arrays:
    - Many programming languages support arrays with named indexes.
      Arrays with named indexes are called associative arrays (or hashes).
      JavaScript does not support arrays with named indexes.
      In JavaScript, arrays always use numbered indexes.
    - NOTE:
      - If you use named indexes, JavaScript will redefine the array to an object.
        After that, some array methods and properties will produce incorrect results.
      - JavaScript new Array():
        - JavaScript has a built-in array constructor new Array().
          But you can safely use [] instead.
            const points = new Array();
            const points = [];
          The new keyword can produce some unexpected results.
      - A Common Error:
        - const points = [40];
          is not the same as:
          const points = new Array(40);
  - The Difference Between Arrays and Objects:
    - In JavaScript, arrays use numbered indexes.
    - In JavaScript, objects use named indexes.
    - Arrays are a special kind of objects, with numbered indexes.
    - JavaScript does not support associative arrays.
      - You should use objects when you want the element names to be strings (text).
      - You should use arrays when you want the element names to be numbers.
  - How to Recognize an Array:
    - A common question is: How do I know if a variable is an array?
      The problem is that the JavaScript operator typeof returns "object":
    - Array.isArray():
      To solve this problem ECMAScript 5 (JavaScript 2009) defined a new method Array.isArray()
    - To solve this problem ECMAScript 5 (JavaScript 2009) defined a new method Array.isArray():
      const fruits = ["Banana", "Orange", "Apple"];
      fruits instanceof Array;

--------------------JAVASCRIPT Array MEthods-----------------------------
Array Methods:
  - length property returns the length (size) of an array.
  - toString() converts an array to a string of (comma separated) array values.
  - join() method also joins all array elements into a string.
  - Popping and Pushing:
    - Popping items out of an array, or pushing items into an array.
    - pop() method removes the last element from an array.
    - push() method adds a new element to an array (at the end).
  - shift() method removes the first array element and "shifts" all other elements to a lower index.
    shift() method returns the value that was "shifted out".
  - unshift() method adds a new element to an array (at the beginning), and "unshifts" older elements.
    unshift() method returns the new array length.
  - NOTE:
    - Array elements can be deleted using the JavaScript operator delete.
      delete leaves undefined holes in the array.
      Use pop() or shift() instead.
    - JavaScript automatically converts an array to a comma separated string when a primitive value is expected.
    - Finding Max and Min Values in an Array:
      - There are no built-in functions for finding the highest or lowest value in a JavaScript array.
      
  - concat() method creates a new array by merging (concatenating) existing arrays
    concat() method does not change the existing arrays. It always returns a new array.
    concat() method can take any number of array arguments.
    concat() method can also take strings as arguments.
  - Flattening an Array:
    - Flattening an array is the process of reducing the dimensionality of an array.
      The flat() method creates a new array with sub-array elements concatenated to a specified depth.
  - splice() method adds new items to an array:
    - The first parameter (2) defines the position where new elements should be added (spliced in).
      The second parameter (0) defines how many elements should be removed.
      splice() method returns an array with the deleted items.
      With clever parameter setting, you can use splice() to remove elements without leaving "holes" in the array.

  - slice() method slices out a piece of an array.
    slice() method creates a new array.
    slice() method does not remove any elements from the source array.
  
--------------------------------JavaScript Sorting Arrays----------------------------------
- Sorting an Array:
  - sort() method sorts an array alphabetically:
    - sort() function sorts values as strings.
      However, if numbers are sorted as strings, "25" is bigger than "100", because "2" is bigger than "1".
      Because of this, the sort() method will produce incorrect result when sorting numbers.
      You can fix this by providing a compare function:
        - const points = [40, 100, 1, 5, 25, 10];
          points.sort(function(a, b){return a - b});
  - reverse() method reverses the elements in an array.
  - Sorting a whole array is a very inefficient method if you only want to find the highest (or lowest) value.
  - Math.max.apply to find the highest number in an array:
    - code:
      function myArrayMax(arr) {
        return Math.max.apply(null, arr);
      }
    
----------------------JavaScript Array Const------------------------
Arrays are Not Constants:
  - The keyword const is a little misleading.
    It does NOT define a constant array. It defines a constant reference to an array.
    Because of this, we can still change the elements of a constant array.
  - Elements Can be Reassigned:
    - Code:
      const cars = ["Saab", "Volvo", "BMW"];

      // You can change an element:
      cars[0] = "Toyota";
  - Assigned when Declared:
    JavaScript const variables must be assigned a value when they are declared.
    Meaning: An array declared with const must be initialized when it is declared.
    Using const without initializing the array is a syntax error:
    - Code: 
      const cars;
      cars = ["Saab", "Volvo", "BMW"]; //Not work!

An array declared with var does not have block scope.
Redeclaring Arrays:
  - Redeclaring an array declared with var is allowed anywhere in a program.
  - Redeclaring or reassigning an array to const, in the same scope, or in the same block, is not allowed:
  - Redeclaring an array with const, in another scope, or in another block, is allowed:

----------------------JavaScript Date Objects----------------------------------
NOTE:
  - Date objects are static. The "clock" is not "running".
    The computer clock is ticking, date objects are not.
  - JavaScript counts months from 0 to 11:
      January = 0.
      December = 11.
    
JavaScript Date Output:
  - By default, JavaScript will use the browser's time zone and display a date as a full text string.
Creating Date Objects:
  - Date objects are created with the new Date() constructor.
    There are 9 ways to create a new date object:
    new Date()
    new Date(date string)
    new Date(year,month)
    new Date(year,month,day)
    new Date(year,month,day,hours)
    new Date(year,month,day,hours,minutes)
    new Date(year,month,day,hours,minutes,seconds) 
    new Date(year,month,day,hours,minutes,seconds,ms)
    new Date(milliseconds)

  - new Date() creates a date object with the current date and time:
  - new Date(date string) creates a date object from a date string:
  - new Date(year, month, ...) creates a date object with a specified date and time.
  - You cannot omit month. If you supply only one parameter it will be treated as milliseconds.
Previous Century:
  - One and two digit years will be interpreted as 19xx:
      - const d = new Date(99, 11, 24);

new Date(milliseconds):
  - new Date(milliseconds) creates a new date object as milliseconds plus zero time:
  - NOTE:
  |   - JavaScript stores dates as number of milliseconds since January 01, 1970.

Displaying Dates:
  - toDateString() method converts a date to a more readable format:
  - toUTCString() method converts a date to a string using the UTC standard:
  - toISOString() method converts a date to a string using the ISO standard:

----------------------------JavaScript Date Input----------------------------------
There are generally 3 types of JavaScript date input formats:
  - ISO Date	"2015-03-25" (The International Standard)
    Short Date	"03/25/2015"
    Long Date	"Mar 25 2015" or "25 Mar 2015"

JavaScript ISO Dates:
  - ISO 8601 is the international standard for the representation of dates and times.
    The ISO 8601 syntax (YYYY-MM-DD) is also the preferred JavaScript date format.
  - ISO dates can be written without specifying the day (YYYY-MM):
  - ISO dates can be written without month and day (YYYY):
  - ISO dates can be written with added hours, minutes, and seconds (YYYY-MM-DDTHH:MM:SSZ):
      - Date and time is separated with a capital T.
        UTC time is defined with a capital letter Z.
        If you want to modify the time relative to UTC, remove the Z and add +HH:MM or -HH:MM instead:

-------------------JavaScript Set Date Methods-----------------------------------------
Set Date Methods:
  - setDate()	Set the day as a number (1-31)
    setFullYear()	Set the year (optionally month and day)
    setHours()	Set the hour (0-23)
    setMilliseconds()	Set the milliseconds (0-999)
    setMinutes()	Set the minutes (0-59)
    setMonth()	Set the month (0-11)
    setSeconds()	Set the seconds (0-59)
    setTime()	Set the time (milliseconds since January 1, 1970)

------------------JavaScript Math Object---------------------------------------------
Math Properties (Constants):
  - Math.E        // returns Euler's number
    Math.PI       // returns PI
    Math.SQRT2    // returns the square root of 2
    Math.SQRT1_2  // returns the square root of 1/2
    Math.LN2      // returns the natural logarithm of 2
    Math.LN10     // returns the natural logarithm of 10
    Math.LOG2E    // returns base 2 logarithm of E
    Math.LOG10E   // returns base 10 logarithm of E
Math Methods: 
  - Math.round(x)	Returns x rounded to its nearest integer
    Math.ceil(x)	Returns x rounded up to its nearest integer 
    Math.floor(x)	Returns x rounded down to its nearest integer
    Math.trunc(x)	Returns the integer part of x (new in ES6)
    Math.pow(x, y) returns the value of x to the power of y:
    Math.sqrt(x) returns the square root of x:
    Math.log(x) returns the natural logarithm of x.
    Math.log2(x) returns the base 2 logarithm of x.
    Math.log10(x) returns the base 10 logarithm of x.
    abs(x)	Returns the absolute value of x
    acos(x)	Returns the arccosine of x, in radians
    acosh(x)	Returns the hyperbolic arccosine of x
    asin(x)	Returns the arcsine of x, in radians
    asinh(x)	Returns the hyperbolic arcsine of x
    atan(x)	Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians
    atan2(y, x)	Returns the arctangent of the quotient of its arguments
    atanh(x)	Returns the hyperbolic arctangent of x
    cbrt(x)	Returns the cubic root of x
    ceil(x)	Returns x, rounded upwards to the nearest integer
    cos(x)	Returns the cosine of x (x is in radians)
    cosh(x)	Returns the hyperbolic cosine of x
    exp(x)	Returns the value of Ex
    floor(x)	Returns x, rounded downwards to the nearest integer
    log(x)	Returns the natural logarithm (base E) of x
    max(x, y, z, ..., n)	Returns the number with the highest value
    min(x, y, z, ..., n)	Returns the number with the lowest value
    pow(x, y)	Returns the value of x to the power of y
    random()	Returns a random number between 0 and 1
    round(x)	Rounds x to the nearest integer
    sign(x)	Returns if x is negative, null or positive (-1, 0, 1)
    sin(x)	Returns the sine of x (x is in radians)
    sinh(x)	Returns the hyperbolic sine of x
    sqrt(x)	Returns the square root of x
    tan(x)	Returns the tangent of an angle
    tanh(x)	Returns the hyperbolic tangent of a number
    trunc(x)	Returns the integer part of a number (x)
    Math.random() returns a random number between 0 (inclusive),  and 1 (exclusive):
      - Math.random() returns a random number between 0 (inclusive),  and 1 (exclusive):

-----------------------JavaScript Booleans-------------------------------
Boolean Values:
  - Boolean() function to find out if an expression (or a variable) is true:
  - Everything With a "Value" is True:
      - Boolean(100)
        Boolean(3.14)
        Boolean(-15)
  - Comparing two JavaScript objects always return false.

---------------------JavaScript Comparison and Logical Operators------------
Comparison and Logical operators are used to test for true or false.
Comparison Operators:
  ==	equal to
  ===	equal value and equal type
  !=	not equal
  !==	not equal value or not equal type
  >	greater than
  <	less than	
  >=	greater than or equal to
  <=	less than or equal to

Logical Operators:
  &&	and	(x < 10 && y > 1) is true	
  ||	or	(x == 5 || y == 5) is false	
  !	not	!(x == y) is true

Conditional (Ternary) Operator:
  - Syntax:
      - variablename = (condition) ? value1:value2 
      - let voteable = (age < 18) ? "Too young":"Old enough";
The Nullish Coalescing Operator (??):
  - The ?? operator returns the first argument if it is not nullish (null or undefined).
    Otherwise it returns the second argument:
    let name = null;
    let text = "missing";
    let result = name ?? text;

The Optional Chaining Operator (?.):
The ?. operator returns undefined if an object is undefined or null (instead of throwing an error).
  - // Create an object:
    const car = {type:"Fiat", model:"500", color:"white"};
    // Ask for car name:
    document.getElementById("demo").innerHTML = car?.name;

--------------------JavaScript if, else, and else if--------------------
In JavaScript we have the following conditional statements:
  - Use if to specify a block of code to be executed, if a specified condition is true
    Use else to specify a block of code to be executed, if the same condition is false
    Use else if to specify a new condition to test, if the first condition is false
    Use switch to specify many alternative blocks of code to be executed

-------------------JavaScript Switch Statement------------------------
Note: If you omit the break statement, the next case will be executed even if the evaluation does not match the case.
The default keyword specifies the code to run if there is no case match:
  - If default is not the last case in the switch block, remember to end the default case with a break.

Switching Details:
  - If multiple cases matches a case value, the first case is selected.
  - If no matching cases are found, the program continues to the default label.
  - If no default label is found, the program continues to the statement(s) after the switch.

-------------------JavaScript For Loop----------------------------
JavaScript supports different kinds of loops:
  - for - loops through a block of code a number of times
  - for/in - loops through the properties of an object
  - for/of - loops through the values of an iterable object
  - while - loops through a block of code while a specified condition is true
  - do/while - also loops through a block of code while a specified condition is true

From the example above, you can read:
  - Expression 1 sets a variable before the loop starts (let i = 0).
  - Expression 2 defines the condition for the loop to run (i must be less than 5).
  - Expression 3 increases a value (i++) each time the code block in the loop has been executed.

  - Expression 1:
    - Normally you will use expression 1 to initialize the variable used in the loop (let i = 0).
      This is not always the case. JavaScript doesn't care. Expression 1 is optional.
      You can initiate many values in expression 1 (separated by comma):
        for (let i = 0, len = cars.length, text = ""; i < len; i++) {
               text += cars[i] + "<br>";
        }
    - And you can omit expression 1 (like when your values are set before the loop starts):
      let i = 2;
      let len = cars.length;
      let text = "";
      for (; i < len; i++) {
      text += cars[i] + "<br>";
      }
  - Expression 2:
    - Often expression 2 is used to evaluate the condition of the initial variable.
      This is not always the case. JavaScript doesn't care. Expression 2 is also optional.
      If expression 2 returns true, the loop will start over again. If it returns false, the loop will end.
    - NOTE:
      - If you omit expression 2, you must provide a break inside the loop. 
        Otherwise the loop will never end. This will crash your browser.
         Read about breaks in a later chapter of this tutorial.
    - Expression 3:
      - Often expression 3 increments the value of the initial variable.
        This is not always the case. JavaScript doesn't care. Expression 3 is optional.
        Expression 3 can do anything like negative increment (i--), positive increment (i = i + 15), or anything else.
        Expression 3 can also be omitted (like when you increment your values inside the loop):
          let i = 0;
          let len = cars.length;
          let text = "";
          for (; i < len; ) {
            text += cars[i] + "<br>";
            i++;
          }

---------------------------The For In Loop---------------------------------------
- The JavaScript for in statement loops through the properties of an Object:
  Syntax:
    for (key in object) {
    // code block to be executed
    }

- The JavaScript for in statement can also loop over the properties of an Array:
  for (variable in array) {
  code
  }
- NOTE:
  - Do not use for in over an Array if the index order is important.
    The index order is implementation-dependent, and array values may not be accessed in the order you expect.
    It is better to use a for loop, a for of loop, or Array.forEach() when the order is important.

-----------------------------JavaScript For Of---------------------------------
The JavaScript for of statement loops through the values of an iterable object.
It lets you loop over iterable data structures such as Arrays, Strings, Maps, NodeLists, and more:
  - for (variable of iterable) {
    // code block to be executed
    }
variable - For every iteration the value of the next property is assigned to the variable.
Variable can be declared with const, let, or var.
iterable - An object that has iterable properties.

------------------------------JavaScript While Loop--------------------------------------
The While Loop:
  - The while loop loops through a block of code as long as a specified condition is true.
  - Syntax:
      while (condition) {
      // code block to be executed
      }

---------------------------JavaScript Iterables------------------------------------------
Iterables are iterable objects (like Arrays).
Iterables can be accessed with simple and efficient code.
Iterables can be iterated over with for..of loops
Iterating:
  - terating is easy to understand.
    It simply means looping over a sequence of elements.
    Here are some easy examples:
      - Iterating over a String
        Iterating over an Array

---------------------------JavaScript Sets-----------------------------------------------
Defination:
  - A JavaScript Set is a collection of unique values.
    Each value can only occur once in a Set.

Essential Set Methods:
  - new Set()	Creates a new Set
    add()	Adds a new element to the Set
    delete()	Removes an element from a Set
    has()	Returns true if a value exists in the Set
    forEach()	Invokes a callback for each element in the Set
    values()	Returns an iterator with all the values in a Set
    Property	Description:
      - size	Returns the number of elements in a Set
Set iteration:
  - The values() Method:
    - let text = "";
      for (const x of letters.values()) {
        text += x;
      }

  - The forEach() Method:
    - // Create a Set
      const letters = new Set(["a","b","c"]);

      // List all Elements
      let text = "";
      letters.forEach (function(value) {
      text += value;
    })

----------------------------JavaScript Maps---------------------------------------
NOTE:
  - A Map holds key-value pairs where the keys can be any datatype.
    A Map remembers the original insertion order of the keys.
  - Essential Map Methods:
    - Method	Description
        new Map()	Creates a new Map
        set()	Sets the value for a key in a Map:
          - set() method can also be used to change existing Map values.
        get()	Gets the value for a key in a Map
        delete()	Removes a Map element specified by the key
        has()	Returns true if a key exists in a Map
        forEach()	Calls a function for each key/value pair in a Map
        entries()	Returns an iterator with the [key, value] pairs in a Map
        Property	Description
        size	Returns the number of elements in a Map
JavaScript Objects vs Maps:
                  Object	                            Map
    Iterable    	Not directly iterable	              Directly iterable
    Size	        Do not have a size property	        Have a size property
    Key Types    	Keys must be Strings (or Symbols)  	Keys can be any datatype
    Key Order	    Keys are not well ordered          	Keys are ordered by insertion
    Defaults	    Have default keys                 	Do not have default keys
The forEach() Method:
  - // List all entries
    let text = "";
    fruits.forEach (function(value, key) {
      text += key + ' = ' + value;
    })

---------------------------JavaScript typeof------------------------------------------
In JavaScript there are 5 different data types that can contain values:
  - string
    number
    boolean
    object
    function
There are 6 types of objects:
  - Object
    Date
    Array
    String
    Number
    Boolean
2 data types that cannot contain values:
  - null:
      - In JavaScript null is "nothing". It is supposed to be something that doesn't exist.
        Unfortunately, in JavaScript, the data type of null is an object.
      - You can consider it a bug in JavaScript that typeof null is an object. It should be null.

    undefined:
      - Any variable can be emptied, by setting the value to undefined. The type will also be undefined.
    Difference Between Undefined and Null:
        undefined and null are equal in value but different in type:
      - typeof undefined           // undefined
        typeof null                // object

    null === undefined         // false
    null == undefined          // true
Please observe:
  - The data type of NaN is number
    The data type of an array is object
    The data type of a date is object
    The data type of null is object
    The data type of an undefined variable is undefined *
   The data type of a variable that has not been assigned a value is also undefined *
NOTE:  You cannot use typeof to determine if a JavaScript object is an array (or a date).

Primitive Data:
  - A primitive data value is a single simple data value with no additional properties and methods.
    The typeof operator can return one of these primitive types:
      - string
        number
        boolean
        undefined
Complex Data:
  - The typeof operator can return one of two complex types:
      function
      object
  - The typeof operator returns "object" for objects, arrays, and null.
    The typeof operator does not return "object" for functions.
  - The typeof operator returns "object" for arrays because in JavaScript arrays are objects.
The constructor Property:
The constructor property returns the constructor function for all JavaScript variables.
"John".constructor                // Returns function String()  {[native code]}
(3.14).constructor                // Returns function Number()  {[native code]}
false.constructor                 // Returns function Boolean() {[native code]}
[1,2,3,4].constructor             // Returns function Array()   {[native code]}
{name:'John',age:34}.constructor  // Returns function Object()  {[native code]}
new Date().constructor            // Returns function Date()    {[native code]}
function () {}.constructor        // Returns function Function(){[native code]}

You can check the constructor property to find out if an object is an Array (contains the word "Array"):
  - function isArray(myArray) {
  return myArray.constructor.toString().indexOf("Array") > -1;
}
Or even simpler, you can check if the object is an Array function:
  - function isArray(myArray) {
  return myArray.constructor === Array;
}
ou can check the constructor property to find out if an object is a Date (contains the word "Date"):
  - function isDate(myDate) {
      return myDate.constructor.toString().indexOf("Date") > -1;
    }

The instanceof Operator:
  - The instanceof operator returns true if an object is an instance of the specified object:

The void Operator:
  - The void operator evaluates an expression and returns undefined. 
  This operator is often used to obtain the undefined primitive value, 
  using "void(0)" (useful when evaluating an expression without using the return value).

--------------------------------JavaScript Type Conversion------------------------------------
JavaScript variables can be converted to a new variable and another data type:
  - By the use of a JavaScript function
    Automatically by JavaScript itself
Converting Strings to Numbers:
  - The global method Number() converts a variable (or a value) into a number.
    A numeric string (like "3.14") converts to a number (like 3.14).
    An empty string (like "") converts to 0.
    A non numeric string (like "John") converts to NaN (Not a Number).
Number Methods:
  - Number()	Returns a number, converted from its argument
    parseFloat()	Parses a string and returns a floating point number
    parseInt()	Parses a string and returns an integer
The Unary + Operator:
  - The unary + operator can be used to convert a variable to a number:
    let y = "5";      // y is a string
    let x = + y;      // x is a number
Converting Numbers to Strings:
  - The global method String() can convert numbers to strings.
    It can be used on any type of numbers, literals, variables, or expressions:
More Methods:
  - toExponential()	Returns a string, with a number rounded and written using exponential notation.
    toFixed()	Returns a string, with a number rounded and written with a specified number of decimals.
    toPrecision()	Returns a string, with a number written with a specified length
Automatic Type Conversion:
  - When JavaScript tries to operate on a "wrong" data type, it will try to convert the value to a "right" type.
    The result is not always what you expect:
    5 + null    // returns 5         because null is converted to 0
    "5" + null  // returns "5null"   because null is converted to "null"
    "5" + 2     // returns "52"      because 2 is converted to "2"
    "5" - 2     // returns 3         because "5" is converted to 5
    "5" * "2"   // returns 10        because "5" and "2" are converted to 5 and 2

-------------------------JavaScript Bitwise Operations--------------------------------
JavaScript Bitwise Operators:
  - &	AND	Sets each bit to 1 if both bits are 1
    |	OR	Sets each bit to 1 if one of two bits is 1
    ^	XOR	Sets each bit to 1 if only one of two bits is 1
    ~	NOT	Inverts all the bits
    <<	Zero fill left shift	Shifts left by pushing zeros in from the right and let the leftmost bits fall off
    >>	Signed right shift	Shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off
    >>>	Zero fill right shift	Shifts right by pushing zeros in from the left, and let the rightmost bits fall off
JavaScript Uses 32 bits Bitwise Operands:

-------------------------JavaScript Regular Expressions--------------------------------------------------
A regular expression is a sequence of characters that forms a search pattern.
The search pattern can be used for text search and text replace operations.
What Is a Regular Expression?:
  - A regular expression is a sequence of characters that forms a search pattern.
    When you search for data in a text, you can use this search pattern to describe what you are searching for.
    A regular expression can be a single character, or a more complicated pattern.
    Regular expressions can be used to perform all types of text search and text replace operations.
Syntax:
  - /pattern/modifiers;
Example:
  - /w3schools/i;
  Example explained:
    - /w3schools/i  is a regular expression.
    - w3schools  is a pattern (to be used in a search).
    - i  is a modifier (modifies the search to be case-insensitive).
Using String Methods:
  - In JavaScript, regular expressions are often used with the two string methods: search() and replace().
  - The search() method uses an expression to search for a match, and returns the position of the match.
  - The replace() method returns a modified string where the pattern is replaced.
Did You Notice? :
  - Regular expression arguments (instead of string arguments) can be used in the methods above.
  - Regular expressions can make your search much more powerful (case insensitive for example).
Regular Expression Modifiers:
  - Modifier                   	Description	Try it
    i	                          Perform case-insensitive matching	
    g	                          Perform a global match (find all matches rather than stopping after the first match)	
    m	                          Perform multiline matching
Regular Expression Patterns:
- Brackets are used to find a range of characters:
  - Expression	       Description	Try it
    [abc]	             Find any of the characters between the brackets	
    [0-9]	             Find any of the digits between the brackets	
    (x|y)	             Find any of the alternatives separated with |
- Metacharacters are characters with a special meaning:
  - Metacharacter	                 Description	Try it
    \d	                           Find a digit	
    \s	                           Find a whitespace character	
    \b	                           Find a match at the beginning of a word like this: \bWORD, or at the end of a word like this: WORD\b	
    \uxxxx	                       Find the Unicode character specified by the hexadecimal number xxxx
 - Quantifiers define quantities:
   - Quantifier	                   Description	Try it
     n+	                           Matches any string that contains at least one n
     n*	                           Matches any string that contains zero or more occurrences of n
     n?	                           Matches any string that contains zero or one occurrences of n
Note:
  - You don't have to put the regular expression in a variable first. The two lines above can be shortened to one:
    /e/.test("The best things in life are free!");
Using exec():
  - The exec() method is a RegExp expression method:
    - t searches a string for a specified pattern, and returns the found text as an object.
      If no match is found, it returns an empty (null) object.
      The following example searches a string for the character "e":

----------------------------JavaScript Operator Precedence-----------------------------------------------------
Explantation:
  - Operator precedence describes the order in which operations are performed in an arithmetic expression.
  - Multiplication (*) and division (/) have higher precedence than addition (+) and subtraction (-).
    - As in traditional mathematics, multiplication is done first:
      let x = 100 + 50 * 3;
  

----------------------------JavaScript Errors-----------------------------------------
Throw, and Try...Catch...Finally:
  - The try statement defines a code block to run (to try).
  - The catch statement defines a code block to handle any error.
  - The finally statement defines a code block to run regardless of the result.
  - The throw statement defines a custom error.
Try:
  - The try statement allows you to define a block of code to be tested for errors while it is being executed.
Catch:
  - The catch statement allows you to define a block of code to be executed, if an error occurs in the try block.
JavaScript Throws Errors:
  - JavaScript will actually create an Error object with two properties: name and message.
The throw Statement:
  - The throw statement allows you to create a custom error.
    Technically you can throw an exception (throw an error).
    The exception can be a JavaScript String, a Number, a Boolean or an Object:
  - If you use throw together with try and catch, you can control program flow 
    and generate custom error messages.
The finally Statement:
  - The finally statement lets you execute code, after try and catch, regardless of the result:
      try {
        Block of code to try
      }catch(err) { 
        Block of code to handle errors
      } finally { 
        Block of code to be executed regardless of the try / catch result
      }
The Error Object:
  - JavaScript has a built in error object that provides error information when an error occurs.
    The error object provides two useful properties: name and message.
    Error Object Properties:
      - name	Sets or returns an error name
      - message	Sets or returns an error message (a string)
    - Error Name Values:
        - EvalError	An error has occurred in the eval() function
          RangeError	A number "out of range" has occurred
          ReferenceError	An illegal reference has occurred
          SyntaxError	A syntax error has occurred
          TypeError	A type error has occurred
          URIError	An error in encodeURI() has occurred
  - Eval Error:
      - An EvalError indicates an error in the eval() function.
      - Newer versions of JavaScript do not throw EvalError. Use SyntaxError instead.
  - Range Error:
      - A RangeError is thrown if you use a number that is outside the range of legal values.
  - Reference Error:
      - A ReferenceError is thrown if you use (reference) a variable that has not been declared:
  - Syntax Error:
      - A SyntaxError is thrown if you try to evaluate code with a syntax error.
  - Type Error:
      - A TypeError is thrown if you use a value that is outside the range of expected types:
  - URI (Uniform Resource Identifier) Error:
      - A URIError is thrown if you use illegal characters in a URI function:
Non-Standard Error Object Properties:
  - Mozilla and Microsoft define some non-standard error object properties:
    fileName (Mozilla)
    lineNumber (Mozilla)
    columnNumber (Mozilla)
    stack (Mozilla)
    description (Microsoft)
    number (Microsoft)
    Do not use these properties in public web sites. They will not work in all browsers.

-------------------------------JavaScript Scope---------------------------------------
Scope determines the accessibility (visibility) of variables.
JavaScript has 3 types of scope:
  - Block scope
    Function scope
    Global scope
Block Scope:
  - ES6 introduced two important new JavaScript keywords: let and const.
    These two keywords provide Block Scope in JavaScript.
    Variables declared inside a { } block cannot be accessed from outside the block:
    Example
    {
      let x = 2;
    } // x can NOT be used here
    Note: Variables declared with the var keyword can NOT have block scope.
Automatically Global:
  - If you assign a value to a variable that has not been declared, it will automatically become a GLOBAL variable.
  - In "Strict Mode", undeclared variables are not automatically global.
Global Variables in HTML:
  - Global variables defined with the var keyword belong to the window object.
  - Global variables defined with the let keyword do not belong to the window object.
  - Warning:
      - Do NOT create global variables unless you intend to.
        Your global variables (or functions) can overwrite window variables (or functions).
        Any function, including the window object, can overwrite your global variables and functions.
The Lifetime of JavaScript Variables:
  - The lifetime of a JavaScript variable starts when it is declared.
  - Function (local) variables are deleted when the function is completed.
  - In a web browser, global variables are deleted when you close the browser window (or tab).
Function Arguments:
  - Function arguments (parameters) work as local variables inside functions.

-----------------------------JavaScript Hoisting-------------------------------------------
- Hoisting is JavaScript's default behavior of moving declarations to the top.
JavaScript Declarations are Hoisted:
  - In JavaScript, a variable can be declared after it has been used.
    In other words; a variable can be used before it has been declared.
  - Hoisting is JavaScript's default behavior of moving all declarations to the top of the
    current scope (to the top of the current script or the current function).
The let and const Keywords:
  - Variables defined with let and const are hoisted to the top of the block, but not initialized.
  - Meaning: The block of code is aware of the variable, but it cannot be used until it has been declared.
JavaScript Initializations are Not Hoisted:
  - JavaScript only hoists declarations, not initializations.
Declare Your Variables At the Top !:
  - Hoisting is (to many developers) an unknown or overlooked behavior of JavaScript.
    If a developer doesn't understand hoisting, programs may contain bugs (errors).
    To avoid bugs, always declare all variables at the beginning of every scope.
    Since this is how JavaScript interprets the code, it is always a good rule.

--------------------------JavaScript Use Strict----------------------------------------------
- "use strict"; Defines that JavaScript code should be executed in "strict mode".
  The "use strict" directive was new in ECMAScript version 5.
  It is not a statement, but a literal expression, ignored by earlier versions of JavaScript.
  The purpose of "use strict" is to indicate that the code should be executed in "strict mode".
  With strict mode, you can not, for example, use undeclared variables.
Declaring Strict Mode:
  - Strict mode is declared by adding "use strict"; to the beginning of a script or a function.
Not Allowed in Strict Mode:
  - Using a variable, without declaring it, is not allowed:
    "use strict";
    x = 3.14;                // This will cause an error
  - Objects are variables too.
    Using an object, without declaring it, is not allowed:
    "use strict";
    x = {p1:10, p2:20};      // This will cause an error
  - Deleting a variable (or object) is not allowed.
    "use strict";
    let x = 3.14;
    delete x;      
  - Deleting a function is not allowed.
    "use strict";
    function x(p1, p2) {};
    delete x;                // This will cause an error 
  - Duplicating a parameter name is not allowed:
    "use strict";
    function x(p1, p1) {};   // This will cause an error
  - Octal numeric literals are not allowed:
    "use strict";
    let x = 010;             // This will cause an error
  - Octal escape characters are not allowed:
    "use strict";
    let x = "\010";            // This will cause an error
  - Writing to a read-only property is not allowed:
    "use strict";
    const obj = {};
    Object.defineProperty(obj, "x", {value:0, writable:false});
    obj.x = 3.14;            // This will cause an error
  - Writing to a get-only property is not allowed:
    "use strict";
    const obj = {get x() {return 0} };
    obj.x = 3.14;            // This will cause an error
  - Deleting an undeletable property is not allowed:
    "use strict";
    delete Object.prototype; // This will cause an error
  - The word eval cannot be used as a variable:
    "use strict";
    let eval = 3.14;         // This will cause an error
  - The word arguments cannot be used as a variable:
    "use strict";
    let arguments = 3.14;    // This will cause an error
  - The with statement is not allowed:
    "use strict";
    with (Math){x = cos(2)}; // This will cause an error
  - For security reasons, eval() is not allowed to create variables in the scope from which it was called.
    In strict mode, a variable can not be used before it is declared:
    "use strict";
    eval ("x = 2");
    alert (x);      // This will cause an error 
  - In strict mode, eval() can not declare a variable using the var keyword:
    "use strict";
    eval ("var x = 2");
    alert (x);    // This will cause an error
  - eval() can not declare a variable using the let keyword:
    eval ("let x = 2");
    alert (x);        // This will cause an error
  - The this keyword in functions behaves differently in strict mode.
    The this keyword refers to the object that called the function.
    If the object is not specified, functions in strict mode will return undefined and functions in normal mode will return the global object (window):
    "use strict";
    function myFunction() {
      alert(this); // will alert "undefined"
      }
    myFunction();
Future Proof!:
  - Keywords reserved for future JavaScript versions can NOT be used as variable names in strict mode.
    These are:
    implements
    interface
    let
    package
    private
    protected
    public
    static
    yield
    "use strict";
    let public = 1500;      // This will cause an error
Watch Out!:
  - The "use strict" directive is only recognized at the beginning of a script or a function.

  ----------------------------The JavaScript this Keyword--------------------------------------------
  What is this?:
    - In JavaScript, the this keyword refers to an object.
      Which object depends on how this is being invoked (used or called).
      The this keyword refers to different objects depending on how it is used:
    - In an object method, this refers to the object.
      Alone, this refers to the global object.
      In a function, this refers to the global object.
      In a function, in strict mode, this is undefined.
      In an event, this refers to the element that received the event.
      Methods like call(), apply(), and bind() can refer this to any object.
Note:
  - this is not a variable. It is a keyword. You cannot change the value of this.
this in a Method:
  - When used in an object method, this refers to the object.
this Alone:
  - When used alone, this refers to the global object.
this in a Function (Default):
  - In a function, the global object is the default binding for this.
this in a Function (Strict):
  - JavaScript strict mode does not allow default binding.
    So, when used in a function, in strict mode, this is undefined.
      - "use strict";
        function myFunction() {
          return this;
        }
this in Event Handlers:
  - In HTML event handlers, this refers to the HTML element that received the event:
      - <button onclick="this.style.display='none'">
          Click to Remove Me!
        </button>
Function Borrowing:
  - With the bind() method, an object can borrow a method from another object.
    This example creates 2 objects (person and member).
    The member object borrows the fullname method from the person object:
This Precedence:
  - To determine which object this refers to; use the following precedence of order.
    1	bind()
    2	apply() and call()
    3	Object method
    4	Global scope

------------------------------JavaScript Arrow Function--------------------------------------
Arrow functions allow us to write shorter function syntax:
  - let myFunction = (a, b) => a * b;
NOTE:
  - It gets shorter! If the function has only one statement,
    and the statement returns a value, you can remove the brackets and the return keyword:
      - hello = () => "Hello World!";
  Note: Note: This works only if the function has only one statement.
  - If you have parameters, you pass them inside the parentheses:
    - hello = (val) => "Hello " + val;
  - In fact, if you have only one parameter, you can skip the parentheses as well:
    - hello = val => "Hello " + val;
What About this?:
  - The handling of this is also different in arrow functions compared to regular functions.
    In short, with arrow functions there are no binding of this.
    In regular functions the this keyword represented the object that called the function,
    which could be the window, the document, a button or whatever.
    With arrow functions the this keyword always represents the object that defined the arrow function.
  - Note:
    - Remember these differences when you are working with functions. 
      Sometimes the behavior of regular functions is what you want, if not, use arrow functions.

-------------------------------JavaScript Classes-----------------------------------------------
ECMAScript 2015, also known as ES6, introduced JavaScript Classes.
JavaScript Classes are templates for JavaScript Objects.
JavaScript Class Syntax:
  - Use the keyword class to create a class.
    Always add a method named constructor():
      - class ClassName {
          constructor() { ... }
        }
Note:
  - A JavaScript class is not an object.It is a template for JavaScript objects.
The Constructor Method:
  - The constructor method is called automatically when a new object is created.

  - The constructor method is a special method:
    - It has to have the exact name "constructor"
      It is executed automatically when a new object is created
      It is used to initialize object properties

    - If you do not define a constructor method, JavaScript will add an empty constructor method.

Class Methods:
  - Class methods are created with the same syntax as object methods.
    Use the keyword class to create a class.
    Always add a constructor() method.
  - Syntax:
    class ClassName { 
      constructor() { ... }
      method_1() { ... }
      method_2() { ... }
      method_3() { ... }
    }

---------------------------------JavaScript Modules---------------------------------------------
Modules:
  - JavaScript modules allow you to break up your code into separate files.
    This makes it easier to maintain a code-base.
    Modules are imported from external files with the import statement.
    Modules also rely on type="module" in the <script> tag.
    Example:
      <script type="module">
        import message from "./message.js";
      </script>
Export:
  - Modules with functions or variables can be stored in any external file.
    There are two types of exports: Named Exports and Default Exports.
  - Named Exports:
    - Let us create a file named person.js, and fill it with the things we want to export.
      You can create named exports two ways. In-line individually, or all at once at the bottom.
      In-line individually:
        - person.js
          export const name = "Jesse";
          export const age = 40;
      All at once at the bottom:
        - person.js
          const name = "Jesse";
          const age = 40;
          export {name, age};
  - Default Exports:
    - Let us create another file, named message.js, and use it for demonstrating default export.

Import:
  - You can import modules into a file in two ways, based on if they are named exports or default exports.
    Named exports are constructed using curly braces. Default exports are not.
    Import from named exports:
      - Import named exports from the file person.js:
        - import { name, age } from "./person.js";
    Import from default exports:
      - Import a default export from the file message.js:
        - import message from "./message.js";

------------------------------JavaScript JSON-------------------------------------------------------
JSON is a format for storing and transporting data.
JSON is often used when data is sent from a server to a web page.
What is JSON?:
  - JSON stands for JavaScript Object Notation
    JSON is a lightweight data interchange format
    JSON is language independent *
    JSON is "self-describing" and easy to understand

  - * The JSON syntax is derived from JavaScript object notation syntax,
     but the JSON format is text only. Code for reading and generating JSON
      data can be written in any programming language.
JSON Example:
  - This JSON syntax defines an employees object: an array of 3 employee records (objects):
    - JSON Example:
      - {
        "employees":[
          {"firstName":"John", "lastName":"Doe"},
          {"firstName":"Anna", "lastName":"Smith"},
          {"firstName":"Peter", "lastName":"Jones"}
         ]
        }
The JSON Format Evaluates to JavaScript Objects:
  - The JSON format is syntactically identical to the code for creating JavaScript objects.
  - Because of this similarity, a JavaScript program can easily convert JSON data into native JavaScript objects.
JSON Syntax Rules:
 - Data is in name/value pairs
   Data is separated by commas
  Curly braces hold objects
  Square brackets hold arrays
JSON Data - A Name and a Value:
  - JSON data is written as name/value pairs, just like JavaScript object properties.
  - A name/value pair consists of a field name (in double quotes), followed by a colon, followed by a value:
    - "firstName":"John"
NOTE: - JSON names require double quotes. JavaScript names do not.
JSON Objects:
  - JSON objects are written inside curly braces.
  - Just like in JavaScript, objects can contain multiple name/value pairs:
    - {"firstName":"John", "lastName":"Doe"}; 
JSON Arrays:
  - JSON arrays are written inside square brackets.
  - Just like in JavaScript, an array can contain objects:
    - "employees":[
      {"firstName":"John", "lastName":"Doe"},
      {"firstName":"Anna", "lastName":"Smith"},
      {"firstName":"Peter", "lastName":"Jones"}
      ]
Converting a JSON Text to a JavaScript Object:
  - A common use of JSON is to read data from a web server, and display the data in a web page.
  - For simplicity, this can be demonstrated using a string as input.
  - First, create a JavaScript string containing JSON syntax:
    - let text = '{ "employees" : [' +
      '{ "firstName":"John" , "lastName":"Doe" },' +
      '{ "firstName":"Anna" , "lastName":"Smith" },' +
      '{ "firstName":"Peter" , "lastName":"Jones" } ]}';

-------------------------------JavaScript Debugging---------------------------------------------
Code Debugging:
  - Programming code might contain syntax errors, or logical errors.
    Many of these errors are difficult to diagnose.
    Often, when programming code contains errors, nothing will happen. There are no error messages, and you will get no indications where to search for errors.
    Searching for (and fixing) errors in programming code is called code debugging.

JavaScript Debuggers:
  - Debugging is not easy. But fortunately, all modern browsers have a built-in JavaScript debugger.
    With a debugger, you can also set breakpoints (places where code execution can be stopped), 
    and examine variables while the code is executing.
    Normally (otherwise follow the steps at the bottom of this page),
     you activate debugging in your browser with the F12 key, and select "Console" in the debugger menu.
  - Setting Breakpoints:
    - In the debugger window, you can set breakpoints in the JavaScript code.
      At each breakpoint, JavaScript will stop executing, and let you examine JavaScript values.
      After examining values, you can resume the execution of code (typically with a play button).
  - The debugger Keyword:
    - The debugger keyword stops the execution of JavaScript, and calls (if available) the debugging function.
      This has the same function as setting a breakpoint in the debugger.
      If no debugging is available, the debugger statement has no effect.
      With the debugger turned on, this code will stop executing before it executes the third line.
  - Debugging is the process of testing, finding, and reducing bugs (errors) in computer programs.
    The first known computer bug was a real bug (an insect) stuck in the electronics.

--------------------------JavaScript Style Guide--------------------------------------------------
JavaScript Coding Conventions:
  - Coding conventions are style guidelines for programming. They typically cover:
    - Naming and declaration rules for variables and functions.
    - Rules for the use of white space, indentation, and comments.
    - Programming practices and principles.
  - Coding conventions secure quality:
    - Improve code readability
    - Make code maintenance easier
Variable Names:
  - At W3schools we use camelCase for identifier names (variables and functions).
    All names start with a letter.
Spaces Around Operators:
  - Always put spaces around operators ( = + - * / ), and after commas:
    - Examples:
      let x = y + z;
      const myArray = ["Volvo", "Saab", "Fiat"];
Code Indentation:
  - Always use 2 spaces for indentation of code blocks:
    - Functions:
      function toCelsius(fahrenheit) {
        return (5 / 9) * (fahrenheit - 32);
      }
    - Do not use tabs (tabulators) for indentation. Different editors interpret tabs differently.
Statement Rules:
  - General rules for simple statements:
    Always end a simple statement with a semicolon.

    const cars = ["Volvo", "Saab", "Fiat"];
    const person = {
    firstName: "John",
    lastName: "Doe",
    age: 50,
    eyeColor: "blue"
    };
  - General rules for complex (compound) statements:
    - Put the opening bracket at the end of the first line.
      Use one space before the opening bracket.
      Put the closing bracket on a new line, without leading spaces.
      Do not end a complex statement with a semicolon.
    - Functions:
      function toCelsius(fahrenheit) {
        return (5 / 9) * (fahrenheit - 32);
      }
    - Loops:
      for (let i = 0; i < 5; i++) {
        x += i;
      }
    - Conditionals:
      if (time < 20) {
        greeting = "Good day";
        } else {
          greeting = "Good evening";
        }
Object Rules:
  - General rules for object definitions:
    - Place the opening bracket on the same line as the object name.
      Use colon plus one space between each property and its value.
      Use quotes around string values, not around numeric values.
      Do not add a comma after the last property-value pair.
      Place the closing bracket on a new line, without leading spaces.
      Always end an object definition with a semicolon.
    - Example:
      const person = {
      firstName: "John",
      lastName: "Doe",
      age: 50,
      eyeColor: "blue"
      };
    - Short objects can be written compressed, on one line, using spaces only between properties, like this:
      const person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};
Line Length < 80:
  - For readability, avoid lines longer than 80 characters.
    If a JavaScript statement does not fit on one line, the best place to break it, is after an operator or a comma.
    Example:
      document.getElementById("demo").innerHTML =
      "Hello Dolly.";
Naming Conventions:
  - Always use the same naming convention for all your code. For example:
    - Variable and function names written as camelCase
      Global variables written in UPPERCASE (We don't, but it's quite common)
      Constants (like PI) written in UPPERCASE
  - Should you use hyp-hens, camelCase, or under_scores in variable names?
    This is a question programmers often discuss. The answer depends on who you ask:
  - Hyphens in HTML and CSS:
    HTML5 attributes can start with data- (data-quantity, data-price).
    CSS uses hyphens in property-names (font-size).
    Note: - Hyphens can be mistaken as subtraction attempts. Hyphens are not allowed in JavaScript names.
  - Underscores:
    - Many programmers prefer to use underscores (date_of_birth), especially in SQL databases.
      Underscores are often used in PHP documentation.
  - PascalCase:
    - PascalCase is often preferred by C programmers.
  - camelCase:
    - camelCase is used by JavaScript itself, by jQuery, and other JavaScript libraries.
    Note: - Do not start names with a $ sign. It will put you in conflict with many JavaScript library names.
Loading JavaScript in HTML:
  - Use simple syntax for loading external scripts (the type attribute is not necessary):
    - <script src="myscript.js"></script>
Accessing HTML Elements:
  - A consequence of using "untidy" HTML styles, might result in JavaScript errors.
    These two JavaScript statements will produce different results:
      - const obj = getElementById("Demo")
        const obj = getElementById("demo")
File Extensions:
  - HTML files should have a .html extension (.htm is allowed).
  - CSS files should have a .css extension.
  - JavaScript files should have a .js extension.
Use Lower Case File Names:
  - Most web servers (Apache, Unix) are case sensitive about file names:
    - london.jpg cannot be accessed as London.jpg.
    - Other web servers (Microsoft, IIS) are not case sensitive:
    - london.jpg can be accessed as London.jpg or london.jpg.
    - If you use a mix of upper and lower case, you have to be extremely consistent.
    - If you move from a case insensitive, to a case sensitive server, even small errors can break your web site.
    - To avoid these problems, always use lower case file names (if possible).
Performance:
  - Coding conventions are not used by computers. Most rules have little impact on the execution of programs.
    Indentation and extra spaces are not significant in small scripts.
    For code in development, readability should be preferred. Larger production scripts should be minimized.

----------------------------------JavaScript Best Practices---------------------------------------------------
Avoid global variables, avoid new, avoid ==, avoid eval()
Avoid Global Variables:
  - Minimize the use of global variables.
    This includes all data types, objects, and functions.
    Global variables and functions can be overwritten by other scripts.
    Use local variables instead, and learn how to use closures.
Always Declare Local Variables:
  - All variables used in a function should be declared as local variables.
  - Local variables must be declared with the var, the let, or the const keyword, otherwise they will become global variables.
  - Strict mode does not allow undeclared variables.
Declarations on Top:
  - It is a good coding practice to put all declarations at the top of each script or function.
  - This will:
    - Give cleaner code
      Provide a single place to look for local variables
      Make it easier to avoid unwanted (implied) global variables
      Reduce the possibility of unwanted re-declarations
Initialize Variables:
  - It is a good coding practice to initialize variables when you declare them.
  - This will:
    - Give cleaner code
      Provide a single place to initialize variables
      Avoid undefined values

      // Declare and initiate at the beginning
       let firstName = "";
       let lastName = "";
       let price = 0;
       let discount = 0;
       let fullPrice = 0,
       const myArray = [];
       const myObject = {};
    - Note: - Initializing variables provides an idea of the intended use (and intended data type).
Declare Objects with const:
  - Declaring objects with const will prevent any accidental change of type:
    - Example:
      let car = {type:"Fiat", model:"500", color:"white"};
      car = "Fiat";      // Changes object to string
    - const car = {type:"Fiat", model:"500", color:"white"};
      car = "Fiat";      // Not possible
Declare Arrays with const:
  - Declaring arrays with const will prevent any accidential change of type:
    - Example:
      let cars = ["Saab", "Volvo", "BMW"];
      cars = 3;    // Changes array to number

    - const cars = ["Saab", "Volvo", "BMW"]; 
      cars = 3;    // Not possible

Don't Use new Object():
  - Use "" instead of new String()
  - Use 0 instead of new Number()
  - Use false instead of new Boolean()
  - Use {} instead of new Object()
  - Use [] instead of new Array()
  - Use /()/ instead of new RegExp()
  - Use function (){} instead of new Function()
Beware of Automatic Type Conversions:
  - JavaScript is loosely typed.
    A variable can contain all data types.
    A variable can change its data type:
    - Example:
      let x = "Hello";     // typeof x is a string
      x = 5;               // changes typeof x to a number
  - Beware that numbers can accidentally be converted to strings or NaN (Not a Number).
    When doing mathematical operations, JavaScript can convert numbers to strings:
    
    let x = 5 + 7;       // x.valueOf() is 12,  typeof x is a number
    let x = 5 + "7";     // x.valueOf() is 57,  typeof x is a string
    let x = "5" + 7;     // x.valueOf() is 57,  typeof x is a string
    let x = 5 - 7;       // x.valueOf() is -2,  typeof x is a number
    let x = 5 - "7";     // x.valueOf() is -2,  typeof x is a number
    let x = "5" - 7;     // x.valueOf() is -2,  typeof x is a number
    let x = 5 - "x";     // x.valueOf() is NaN, typeof x is a number
Note:
  - Subtracting a string from a string, does not generate an error but returns NaN (Not a Number):
    Example:
      "Hello" - "Dolly"    // returns NaN
Use === Comparison:
  - The == comparison operator always converts (to matching types) before comparison.
  - The === operator forces comparison of values and type:
    - Example:
      0 == "";        // true
      1 == "1";       // true
      1 == true;      // true

      0 === "";       // false
      1 === "1";      // false
      1 === true;     // false
Use Parameter Defaults:
  - If a function is called with a missing argument, the value of the missing argument is set to undefined.
    Undefined values can break your code. It is a good habit to assign default values to arguments.
    Example:
    function myFunction(x, y) {
      if (y === undefined) {
      y = 0;
      }
    }
    function (a=1, b=1) { /*function code*/ }
End Your Switches with Defaults:
  - Always end your switch statements with a default. Even if you think there is no need for it.
Avoid Number, String, and Boolean as Objects:
  - Always treat numbers, strings, or booleans as primitive values. Not as objects.
    Declaring these types as objects, slows down execution speed, and produces nasty side effects:
    Example:
      let x = "John";             
      let y = new String("John");
      (x === y) // is false because x is a string and y is an object.
    Or even worse:
      Example:
      let x = new String("John");             
      let y = new String("John");
      (x == y) // is false because you cannot compare objects.
Avoid Using eval():
  - The eval() function is used to run text as code. In almost all cases, it should not be necessary to use it.
    Because it allows arbitrary code to be run, it also represents a security problem.